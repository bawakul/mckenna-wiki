---
phase: 06-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/export/markdown.ts
  - src/lib/export/csv.ts
  - src/lib/export/filename.ts
  - src/app/api/export/markdown/[moduleId]/route.ts
  - src/app/api/export/csv/[moduleId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Single module markdown export returns valid markdown with YAML frontmatter"
    - "Single module CSV export returns RFC 4180 compliant CSV"
    - "Exports include all passages for the module, grouped by lecture"
    - "Missing timestamps show 'N/A' placeholder"
  artifacts:
    - path: "src/lib/export/markdown.ts"
      provides: "Markdown generation with YAML frontmatter"
      exports: ["generateMarkdown"]
    - path: "src/lib/export/csv.ts"
      provides: "RFC 4180 compliant CSV generation"
      exports: ["generateCSV"]
    - path: "src/lib/export/filename.ts"
      provides: "Filename sanitization utilities"
      exports: ["generateSafeFilename"]
    - path: "src/app/api/export/markdown/[moduleId]/route.ts"
      provides: "Markdown download endpoint"
      exports: ["GET"]
    - path: "src/app/api/export/csv/[moduleId]/route.ts"
      provides: "CSV download endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/export/markdown/[moduleId]/route.ts"
      to: "src/lib/export/markdown.ts"
      via: "import generateMarkdown"
      pattern: "import.*generateMarkdown.*from.*lib/export/markdown"
    - from: "src/app/api/export/csv/[moduleId]/route.ts"
      to: "src/lib/export/csv.ts"
      via: "import generateCSV"
      pattern: "import.*generateCSV.*from.*lib/export/csv"
    - from: "Route handlers"
      to: "src/lib/queries/module-traces.ts"
      via: "getModuleTraces, getModuleWithCount"
      pattern: "getModuleTraces|getModuleWithCount"
---

<objective>
Create export infrastructure for markdown and CSV downloads

Purpose: Enable downloading module passages as files - the foundational layer for all export functionality. Route Handlers provide download endpoints that the UI will consume in Plan 02.

Output: Working API endpoints at /api/export/markdown/[moduleId] and /api/export/csv/[moduleId] that return properly formatted files with Content-Disposition headers.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-export/06-CONTEXT.md
@.planning/phases/06-export/06-RESEARCH.md

# Existing code patterns
@src/lib/types/trace.ts
@src/lib/types/module.ts
@src/lib/queries/module-traces.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install export dependencies</name>
  <files>package.json</files>
  <action>
Install required dependencies for export functionality:

```bash
npm install client-zip sanitize-filename
npm install --save-dev @types/sanitize-filename
```

**Dependencies:**
- `client-zip` - Browser-side ZIP generation for bulk exports (6.4 kB, 40x faster than JSZip)
- `sanitize-filename` - Cross-platform filename safety (handles reserved names, invalid chars)

Note: `@types/sanitize-filename` provides TypeScript definitions.
  </action>
  <verify>Run `npm ls client-zip sanitize-filename` to confirm packages installed</verify>
  <done>client-zip and sanitize-filename appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create export utility functions</name>
  <files>
    src/lib/export/markdown.ts
    src/lib/export/csv.ts
    src/lib/export/filename.ts
  </files>
  <action>
Create `src/lib/export/` directory with three utility files:

**src/lib/export/filename.ts:**
```typescript
import sanitize from 'sanitize-filename'

/**
 * Generate a safe filename for exports
 * Handles invalid characters, reserved names (CON, NUL), and adds timestamp
 */
export function generateSafeFilename(moduleName: string, extension: string): string {
  const safe = sanitize(moduleName, { replacement: '-' })
  const base = safe || 'export'
  const timestamp = new Date().toISOString().split('T')[0]
  return `${base}-${timestamp}.${extension}`
}
```

**src/lib/export/csv.ts:**
```typescript
import type { ModuleTrace } from '@/lib/types/trace'

/**
 * Escape CSV field per RFC 4180
 * Fields containing comma, quote, or newline must be quoted
 * Quotes inside fields are escaped by doubling ("")
 */
function escapeCSVField(value: string | null): string {
  const str = value ?? 'N/A'
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`
  }
  return str
}

function formatCSVDate(dateStr: string | null): string {
  if (!dateStr) return 'N/A'
  // Parse and format to "Month Year"
  const date = new Date(dateStr)
  return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
}

/**
 * Generate RFC 4180 compliant CSV for module traces
 * Columns: module, passage, lecture_title, date, timestamp
 */
export function generateCSV(moduleName: string, traces: ModuleTrace[]): string {
  const header = ['module', 'passage', 'lecture_title', 'date', 'timestamp']

  const rows = traces.map(t => [
    moduleName,
    t.highlighted_text,
    t.transcript_title,
    formatCSVDate(t.transcript_date),
    'N/A' // Timestamp not stored in selector - use N/A placeholder
  ])

  const allRows = [header, ...rows]
  return allRows
    .map(row => row.map(escapeCSVField).join(','))
    .join('\n')
}
```

**Note on timestamps:** The selector stores paragraph anchors and text quotes but not timestamps. The module_traces view doesn't include paragraph timestamps. Use 'N/A' as decided in CONTEXT.md.

**src/lib/export/markdown.ts:**
```typescript
import type { Module } from '@/lib/types/module'
import type { ModuleTrace } from '@/lib/types/trace'

function formatDate(dateStr: string | null): string {
  if (!dateStr) return ''
  const date = new Date(dateStr)
  return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
}

/**
 * Generate markdown export with YAML frontmatter
 * Passages grouped by lecture, chronologically ordered
 */
export function generateMarkdown(module: { name: string; color: string; notes: string | null }, traces: ModuleTrace[]): string {
  // YAML frontmatter (must be first, triple-dash delimited)
  const frontmatter = `---
module: ${module.name}
color: "${module.color}"
exported: ${new Date().toISOString()}
passage_count: ${traces.length}
---

# ${module.name}

${module.notes || 'No description provided.'}

---

`

  // Group traces by transcript (already sorted chronologically from view)
  const byTranscript = new Map<string, ModuleTrace[]>()
  for (const trace of traces) {
    const key = trace.transcript_id
    if (!byTranscript.has(key)) {
      byTranscript.set(key, [])
    }
    byTranscript.get(key)!.push(trace)
  }

  // Generate sections (traces already in chronological order)
  const sections = Array.from(byTranscript.values()).map(lectureTraces => {
    const first = lectureTraces[0]
    const dateStr = formatDate(first.transcript_date)
    const header = dateStr
      ? `## ${first.transcript_title} (${dateStr})`
      : `## ${first.transcript_title}`

    const passages = lectureTraces.map(t => {
      return `> ${t.highlighted_text}\n`
    }).join('\n')

    return `${header}\n\n${passages}`
  })

  return frontmatter + sections.join('\n---\n\n')
}
```

**Key decisions:**
- Passages rendered as blockquotes for visual distinction
- Horizontal rules between lectures
- Color quoted in YAML to handle hex codes safely
- No timestamp in passages (not available from current data model)
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles without errors</verify>
  <done>Three export utility files exist with generateMarkdown, generateCSV, and generateSafeFilename exports</done>
</task>

<task type="auto">
  <name>Task 3: Create Route Handlers for single module exports</name>
  <files>
    src/app/api/export/markdown/[moduleId]/route.ts
    src/app/api/export/csv/[moduleId]/route.ts
  </files>
  <action>
Create Route Handler endpoints for downloading single module exports:

**src/app/api/export/markdown/[moduleId]/route.ts:**
```typescript
import { getModuleTraces, getModuleWithCount } from '@/lib/queries/module-traces'
import { generateMarkdown } from '@/lib/export/markdown'
import { generateSafeFilename } from '@/lib/export/filename'
import { NextResponse } from 'next/server'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ moduleId: string }> }
) {
  const { moduleId } = await params

  // Parallel fetch module and traces
  const [module, traces] = await Promise.all([
    getModuleWithCount(moduleId),
    getModuleTraces(moduleId)
  ])

  if (!module) {
    return NextResponse.json({ error: 'Module not found' }, { status: 404 })
  }

  // Generate markdown content
  const markdown = generateMarkdown(module, traces)
  const filename = generateSafeFilename(module.name, 'md')

  // Return file with proper headers
  return new Response(markdown, {
    status: 200,
    headers: {
      'Content-Type': 'text/markdown; charset=utf-8',
      'Content-Disposition': `attachment; filename="${filename}"; filename*=UTF-8''${encodeURIComponent(filename)}`,
    },
  })
}
```

**src/app/api/export/csv/[moduleId]/route.ts:**
```typescript
import { getModuleTraces, getModuleWithCount } from '@/lib/queries/module-traces'
import { generateCSV } from '@/lib/export/csv'
import { generateSafeFilename } from '@/lib/export/filename'
import { NextResponse } from 'next/server'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ moduleId: string }> }
) {
  const { moduleId } = await params

  // Parallel fetch module and traces
  const [module, traces] = await Promise.all([
    getModuleWithCount(moduleId),
    getModuleTraces(moduleId)
  ])

  if (!module) {
    return NextResponse.json({ error: 'Module not found' }, { status: 404 })
  }

  // Generate CSV content
  const csv = generateCSV(module.name, traces)
  const filename = generateSafeFilename(module.name, 'csv')

  // Return file with proper headers
  return new Response(csv, {
    status: 200,
    headers: {
      'Content-Type': 'text/csv; charset=utf-8',
      'Content-Disposition': `attachment; filename="${filename}"; filename*=UTF-8''${encodeURIComponent(filename)}`,
    },
  })
}
```

**Key patterns:**
- `await params` for Next.js 15 async params
- Parallel fetch with Promise.all (existing pattern from codebase)
- Content-Disposition with both filename and filename* for UTF-8 safety
- 404 response for invalid module IDs
- Reuse existing query functions (no new database code)
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify TypeScript compiles
2. Start dev server and test endpoints:
   - `curl -I http://localhost:3000/api/export/markdown/[valid-module-id]` should return 200 with Content-Type: text/markdown
   - `curl -I http://localhost:3000/api/export/csv/[valid-module-id]` should return 200 with Content-Type: text/csv
  </verify>
  <done>Route handlers respond with correct Content-Type and Content-Disposition headers</done>
</task>

</tasks>

<verification>
1. **Dependencies installed:** `npm ls client-zip sanitize-filename` shows both packages
2. **Export utilities exist:** Files in src/lib/export/ compile without TypeScript errors
3. **Endpoints functional:**
   - GET /api/export/markdown/[moduleId] returns markdown file download
   - GET /api/export/csv/[moduleId] returns CSV file download
   - Invalid module IDs return 404
4. **Content format correct:**
   - Markdown has YAML frontmatter (starts with ---)
   - CSV has header row and RFC 4180 compliant escaping
</verification>

<success_criteria>
- client-zip and sanitize-filename in package.json
- Export utilities at src/lib/export/{markdown,csv,filename}.ts
- Route Handlers at src/app/api/export/{markdown,csv}/[moduleId]/route.ts
- TypeScript compiles without errors
- Endpoints return files with correct headers
</success_criteria>

<output>
After completion, create `.planning/phases/06-export/06-01-SUMMARY.md`
</output>
