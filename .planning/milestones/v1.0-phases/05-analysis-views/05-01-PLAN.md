---
phase: 05-analysis-views
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/005_create_module_traces_view.sql
  - src/lib/types/trace.ts
  - src/lib/queries/module-traces.ts
autonomous: true

must_haves:
  truths:
    - "Database view exists that joins annotations, transcripts, and modules"
    - "View returns chronologically sorted results (oldest first, nulls last)"
    - "TypeScript types match view output shape"
  artifacts:
    - path: "supabase/migrations/005_create_module_traces_view.sql"
      provides: "module_traces PostgreSQL view"
      contains: "CREATE VIEW module_traces"
    - path: "src/lib/types/trace.ts"
      provides: "ModuleTrace interface"
      exports: ["ModuleTrace"]
    - path: "src/lib/queries/module-traces.ts"
      provides: "Query functions for trace data"
      exports: ["getModuleTraces", "getModuleWithCount"]
  key_links:
    - from: "src/lib/queries/module-traces.ts"
      to: "module_traces view"
      via: "supabase.from('module_traces')"
      pattern: "from\\(['\"]module_traces['\"]\\)"
---

<objective>
Create the database view and TypeScript foundation for module tracing queries.

Purpose: Enable efficient cross-corpus queries that join annotations with transcript metadata and module data, sorted chronologically. This is the data layer that all analysis features will build upon.

Output: PostgreSQL view `module_traces`, TypeScript types, and query functions ready for use by trace page components.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-analysis-views/05-RESEARCH.md

# Existing schema references
@supabase/migrations/001_create_corpus_tables.sql
@supabase/migrations/004_create_annotations_table.sql
@src/lib/types/annotation.ts
@src/lib/types/module.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module_traces database view</name>
  <files>supabase/migrations/005_create_module_traces_view.sql</files>
  <action>
Create PostgreSQL view that denormalizes annotation data with transcript and module metadata:

```sql
CREATE VIEW module_traces AS
SELECT
  a.id,
  a.module_id,
  a.highlighted_text,
  a.selector,
  a.start_paragraph_id,
  a.end_paragraph_id,
  a.created_at as annotation_created_at,
  t.id as transcript_id,
  t.title as transcript_title,
  t.date as transcript_date,
  m.name as module_name,
  m.color as module_color
FROM annotations a
INNER JOIN transcripts t ON a.transcript_id = t.id
LEFT JOIN modules m ON a.module_id = m.id
ORDER BY t.date ASC NULLS LAST, a.created_at ASC;
```

Key decisions from RESEARCH.md:
- INNER JOIN with transcripts (orphaned annotations filtered)
- LEFT JOIN with modules (supports untagged highlights)
- ORDER BY in view (default chronological sort)
- NULLS LAST for lectures with unknown dates
- No materialization (1000 rows is small - regular view sufficient)

Add COMMENT explaining purpose. Existing indexes (idx_annotations_module, idx_annotations_transcript) will accelerate queries.

Run migration: `npx supabase db push` or apply via Supabase dashboard.
  </action>
  <verify>
Query the view in Supabase dashboard SQL editor:
```sql
SELECT * FROM module_traces WHERE module_id IS NOT NULL LIMIT 5;
```
Should return rows with transcript_title, transcript_date, module_name, module_color joined in.
  </verify>
  <done>module_traces view exists and returns chronologically sorted results with joined metadata</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and query functions</name>
  <files>
    src/lib/types/trace.ts
    src/lib/queries/module-traces.ts
  </files>
  <action>
**src/lib/types/trace.ts:**
Create ModuleTrace interface matching the view output:

```typescript
export interface ModuleTrace {
  id: string
  module_id: string | null
  highlighted_text: string
  selector: AnnotationSelector  // from annotation.ts
  start_paragraph_id: number
  end_paragraph_id: number
  annotation_created_at: string
  transcript_id: string
  transcript_title: string
  transcript_date: string | null  // Can be null for unknown dates
  module_name: string | null
  module_color: string | null
}
```

Import AnnotationSelector from annotation.ts for type consistency.

**src/lib/queries/module-traces.ts:**
Create server-side query functions:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { ModuleTrace } from '@/lib/types/trace'

export async function getModuleTraces(moduleId: string): Promise<ModuleTrace[]> {
  const supabase = await createClient()
  const { data, error } = await supabase
    .from('module_traces')
    .select('*')
    .eq('module_id', moduleId)

  if (error) throw error
  return data || []
}

export async function getModuleWithCount(moduleId: string) {
  const supabase = await createClient()

  const [moduleResult, countResult] = await Promise.all([
    supabase.from('modules').select('*').eq('id', moduleId).single(),
    supabase.from('annotations').select('id', { count: 'exact', head: true }).eq('module_id', moduleId)
  ])

  if (moduleResult.error) return null
  return {
    ...moduleResult.data,
    passage_count: countResult.count || 0
  }
}
```

Use Promise.all for parallel fetching (no waterfall).
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit`
No type errors in new files.
  </verify>
  <done>ModuleTrace type and query functions exported, ready for use by page components</done>
</task>

</tasks>

<verification>
1. Database view exists: `SELECT * FROM module_traces LIMIT 1` returns rows
2. TypeScript compiles: `npx tsc --noEmit` passes
3. Query function can be imported: Add temporary test import in a page file
</verification>

<success_criteria>
- module_traces view created in Supabase
- View returns correct columns (id, module_id, highlighted_text, transcript_title, transcript_date, module_name, module_color)
- Results sorted chronologically (oldest transcripts first)
- TypeScript types match view output
- Query functions work with Supabase server client
</success_criteria>

<output>
After completion, create `.planning/phases/05-analysis-views/05-01-SUMMARY.md`
</output>
