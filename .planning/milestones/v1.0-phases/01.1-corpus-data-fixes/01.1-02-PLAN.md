---
phase: 01.1-corpus-data-fixes
plan: 02
type: execute
wave: 2
depends_on:
  - 01.1-01-PLAN.md
files_modified:
  - supabase/transcripts table (data update)
autonomous: true

must_haves:
  truths:
    - "Database transcripts table contains populated date column for transcripts that have dates"
    - "Database transcripts table contains populated topic_tags arrays for transcripts that have tags"
    - "Transcript list sorts chronologically by actual dates"
    - "No duplicate transcript records after re-seed (upsert worked correctly)"
  artifacts:
    - path: "N/A - database state"
      provides: "Updated transcript records with dates and topic_tags"
      contains: "N/A"
  key_links:
    - from: "mckenna-corpus/transcripts/*.json"
      to: "supabase/transcripts"
      via: "import-corpus.ts upsert"
      pattern: "date.*topic_tags"
---

<objective>
Re-seed the database with the updated corpus data containing dates and topic tags, then verify the data is correctly stored and queryable.

Purpose: Complete the Phase 1.1 fix by ensuring the database reflects the newly extracted metadata, enabling chronological sorting and topic filtering in the UI.

Output: Database updated with dates and topic tags; verification queries confirm data integrity.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-corpus-data-fixes/01.1-RESEARCH.md
@.planning/phases/01.1-corpus-data-fixes/01.1-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Re-seed database with updated corpus</name>
  <files>scripts/seed/import-corpus.ts (run only, no modification)</files>
  <action>
    1. Ensure environment variables are set for database access:
       ```bash
       # Verify .env.local contains SUPABASE_URL and SUPABASE_SERVICE_KEY
       grep -l "SUPABASE_URL\|SUPABASE_SERVICE_KEY" .env.local
       ```

    2. Run dry-run first to validate JSON files:
       ```bash
       npm run seed:dry-run
       ```
       Expected: All 92 transcripts validated successfully.

    3. Run the actual seed to update database:
       ```bash
       npm run seed
       ```

    4. Monitor output for:
       - "Updated" messages (indicating content hash changed, records updated)
       - Any "Failed" messages (should be zero)
       - Final summary showing 92 transcripts processed

    5. Expected result:
       - Most transcripts should show "Updated" (content hash includes new metadata in scrapedAt timestamp changes)
       - Zero failures
       - Total count matches 92 transcripts
  </action>
  <verify>
    - Seed output shows 92 transcripts processed
    - Zero failures in seed output
    - Most transcripts show "Updated" status (new metadata triggers update)
  </verify>
  <done>Database re-seeded with updated corpus data including dates and topic tags</done>
</task>

<task type="auto">
  <name>Task 2: Verify database data integrity</name>
  <files>N/A (database queries)</files>
  <action>
    1. Run verification queries in Supabase SQL Editor or via psql:

       **Check date coverage:**
       ```sql
       SELECT
         COUNT(*) as total_transcripts,
         COUNT(CASE WHEN date IS NOT NULL THEN 1 END) as with_dates,
         ROUND(100.0 * COUNT(CASE WHEN date IS NOT NULL THEN 1 END) / COUNT(*), 1) as date_coverage_pct
       FROM transcripts;
       ```
       Expected: High date coverage (>90%)

       **Check topic tag coverage:**
       ```sql
       SELECT
         COUNT(*) as total_transcripts,
         COUNT(CASE WHEN array_length(topic_tags, 1) > 0 THEN 1 END) as with_tags,
         ROUND(100.0 * COUNT(CASE WHEN array_length(topic_tags, 1) > 0 THEN 1 END) / COUNT(*), 1) as tag_coverage_pct
       FROM transcripts;
       ```
       Expected: High tag coverage (>90%)

       **Check for duplicates:**
       ```sql
       SELECT id, COUNT(*) as cnt
       FROM transcripts
       GROUP BY id
       HAVING COUNT(*) > 1;
       ```
       Expected: Empty result (no duplicates)

       **Sample date formats:**
       ```sql
       SELECT id, date
       FROM transcripts
       WHERE date IS NOT NULL
       ORDER BY scraped_at DESC
       LIMIT 10;
       ```
       Record the date formats observed (full date, month/year, year only)

       **Sample topic tags:**
       ```sql
       SELECT id, topic_tags
       FROM transcripts
       WHERE array_length(topic_tags, 1) > 0
       ORDER BY scraped_at DESC
       LIMIT 5;
       ```
       Record sample tags for verification

    2. Document findings:
       - Total transcripts
       - Date coverage percentage
       - Tag coverage percentage
       - Any transcripts without dates (list IDs if less than 10)
       - Any transcripts without tags (list IDs if less than 10)

    3. If coverage is lower than expected (<90%), investigate:
       - Check corresponding HTML samples for those transcripts
       - Verify selector is matching correctly
       - Document as known limitations if source data is genuinely missing
  </action>
  <verify>
    - Date coverage >= 90%
    - Tag coverage >= 90%
    - No duplicate transcript records
    - Sample queries return expected data formats
  </verify>
  <done>Database data integrity verified with coverage metrics documented</done>
</task>

<task type="auto">
  <name>Task 3: Verify chronological sorting works</name>
  <files>N/A (database queries + optional UI check)</files>
  <action>
    1. Test chronological ordering query:
       ```sql
       SELECT id, title, date
       FROM transcripts
       WHERE date IS NOT NULL
       ORDER BY date ASC
       LIMIT 10;
       ```

       Note: Since dates are stored as strings (varying formats like "March 25, 1994", "June 1989"),
       string ordering may not be perfect chronological order. This is a known limitation documented
       in Phase 1 decisions ("store as-is, no normalization").

    2. Check if the existing UI transcript list shows dates:
       - Start dev server: `npm run dev`
       - Navigate to transcript list page
       - Verify dates are displayed (if date column exists in UI)
       - Verify topic tags are displayed (if implemented in UI)

    3. If UI doesn't show dates/tags yet:
       - This is expected - Phase 3 may not have implemented date display
       - Document that database is ready, UI may need updates
       - Check if Phase 3 UI already queries and displays these fields

    4. Document current state for handoff to any UI updates needed.
  </action>
  <verify>
    - ORDER BY date query returns results (even if string ordering)
    - Database has data ready for UI consumption
    - No errors when querying with date/topic_tags filters
  </verify>
  <done>Chronological sorting verified at database level; UI state documented</done>
</task>

<task type="auto">
  <name>Task 4: Generate unique topic tags list</name>
  <files>N/A (database query for documentation)</files>
  <action>
    1. Generate a complete list of unique topic tags in the corpus:
       ```sql
       SELECT DISTINCT unnest(topic_tags) as tag
       FROM transcripts
       ORDER BY tag;
       ```

    2. Count transcripts per tag:
       ```sql
       SELECT tag, COUNT(*) as transcript_count
       FROM transcripts, unnest(topic_tags) as tag
       GROUP BY tag
       ORDER BY transcript_count DESC;
       ```

    3. Document findings:
       - Total unique tags in corpus
       - Top 10 most common tags
       - Any unexpected or malformed tags (whitespace issues, duplicates, etc.)

    4. This data will be useful for:
       - Phase 1.1 verification (success criteria: topic tag filters work)
       - Future UI implementation of topic filters on transcript list page
  </action>
  <verify>
    - Query returns non-empty list of unique tags
    - Tags are properly trimmed (no leading/trailing whitespace)
    - No duplicate tags (case-sensitive check)
  </verify>
  <done>Unique topic tags catalogued with frequency counts</done>
</task>

</tasks>

<verification>
- Seed output: 92 transcripts processed, 0 failures
- Date coverage query: >= 90%
- Tag coverage query: >= 90%
- No duplicate transcripts: `SELECT id, COUNT(*) FROM transcripts GROUP BY id HAVING COUNT(*) > 1` returns empty
- Unique tags query returns non-empty result set
</verification>

<success_criteria>
1. Database re-seeded successfully with 0 failures
2. Date coverage >= 90% of transcripts
3. Topic tag coverage >= 90% of transcripts
4. No duplicate transcript records in database
5. Unique topic tags list generated and documented
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-corpus-data-fixes/01.1-02-SUMMARY.md`

Include in summary:
- Date coverage percentage and any transcripts missing dates
- Tag coverage percentage and any transcripts missing tags
- Complete list of unique topic tags with counts
- Any UI updates needed (if date/tag display not yet implemented)
</output>
