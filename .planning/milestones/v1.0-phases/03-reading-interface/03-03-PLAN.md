---
phase: 03-reading-interface
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - package.json
  - src/components/transcripts/VirtualizedReader.tsx
  - src/components/transcripts/TranscriptReader.tsx
autonomous: true

must_haves:
  truths:
    - "Longest transcript (87K words) scrolls smoothly at 30+ fps"
    - "TanStack Virtual is integrated with dynamic height support"
    - "Only visible paragraphs are rendered in DOM"
    - "React 19 compatibility configured (useFlushSync: false)"
  artifacts:
    - path: "src/components/transcripts/VirtualizedReader.tsx"
      provides: "Virtualized paragraph list using TanStack Virtual"
      min_lines: 80
    - path: "package.json"
      provides: "Updated with @tanstack/react-virtual dependency"
      contains: "@tanstack/react-virtual"
  key_links:
    - from: "src/components/transcripts/VirtualizedReader.tsx"
      to: "@tanstack/react-virtual"
      via: "useVirtualizer hook"
      pattern: "useVirtualizer"
    - from: "src/components/transcripts/TranscriptReader.tsx"
      to: "src/components/transcripts/VirtualizedReader.tsx"
      via: "component composition"
      pattern: "VirtualizedReader"
---

<objective>
Add virtualization to handle large transcripts (up to 87K words) with smooth 30+ fps scrolling.

Purpose: Enable performant reading of longest transcripts (READ-03)
Output: Virtualized paragraph rendering with TanStack Virtual
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reading-interface/03-CONTEXT.md
@.planning/phases/03-reading-interface/03-RESEARCH.md
@.planning/phases/03-reading-interface/03-01-SUMMARY.md
@.planning/phases/03-reading-interface/03-02-SUMMARY.md

# Existing components
@src/components/transcripts/TranscriptReader.tsx
@src/components/transcripts/ParagraphView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TanStack Virtual</name>
  <files>package.json</files>
  <action>
Install @tanstack/react-virtual for virtualization.

```bash
npm install @tanstack/react-virtual
```

Expected addition to package.json dependencies:
```json
{
  "dependencies": {
    "@tanstack/react-virtual": "^3.x"
  }
}
```
  </action>
  <verify>
- @tanstack/react-virtual appears in package.json dependencies
- `npm install` completes without errors
- Package can be imported: `import { useVirtualizer } from '@tanstack/react-virtual'`
  </verify>
  <done>TanStack Virtual installed and ready for use</done>
</task>

<task type="auto">
  <name>Task 2: Create virtualized reader component</name>
  <files>src/components/transcripts/VirtualizedReader.tsx</files>
  <action>
Create a virtualized paragraph list using TanStack Virtual.

Implementation notes (from 03-RESEARCH.md):
- Use `measureElement` for dynamic height support
- Set `useFlushSync: false` for React 19 compatibility
- Use `overscan: 5` for smooth scrolling
- Use padding instead of margin for spacing (height calculation accuracy)
- Use `transform: translateY()` for positioning

```typescript
'use client'

import { useRef, useMemo } from 'react'
import { useVirtualizer } from '@tanstack/react-virtual'
import type { TranscriptParagraph } from '@/lib/types/transcript'
import { ParagraphView, shouldShowSpeaker } from './ParagraphView'

interface VirtualizedReaderProps {
  paragraphs: TranscriptParagraph[]
  searchQuery?: string
  onVisibleRangeChange?: (startIndex: number, endIndex: number) => void
}

export function VirtualizedReader({
  paragraphs,
  searchQuery,
  onVisibleRangeChange,
}: VirtualizedReaderProps) {
  const parentRef = useRef<HTMLDivElement>(null)

  // Memoize speaker visibility calculations
  const speakerVisibility = useMemo(() => {
    return paragraphs.map((para, index) =>
      shouldShowSpeaker(para, paragraphs[index - 1])
    )
  }, [paragraphs])

  const virtualizer = useVirtualizer({
    count: paragraphs.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 80, // Estimated ~3-4 lines of text
    overscan: 5, // Render 5 extra items above/below viewport
    measureElement: (element) => element.getBoundingClientRect().height,
    // React 19 compatibility - prevents flushSync warnings
    useFlushSync: false,
  })

  const virtualItems = virtualizer.getVirtualItems()

  // Notify parent of visible range changes (for position memory)
  useMemo(() => {
    if (onVisibleRangeChange && virtualItems.length > 0) {
      const startIndex = virtualItems[0]?.index ?? 0
      const endIndex = virtualItems[virtualItems.length - 1]?.index ?? 0
      onVisibleRangeChange(startIndex, endIndex)
    }
  }, [virtualItems, onVisibleRangeChange])

  return (
    <div
      ref={parentRef}
      className="h-[calc(100vh-200px)] overflow-auto"
      style={{
        contain: 'strict', // Performance optimization
      }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualItems.map((virtualItem) => {
          const paragraph = paragraphs[virtualItem.index]
          const showSpeaker = speakerVisibility[virtualItem.index]

          return (
            <div
              key={virtualItem.key}
              data-index={virtualItem.index}
              ref={virtualizer.measureElement}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                transform: `translateY(${virtualItem.start}px)`,
              }}
            >
              <ParagraphView
                paragraph={paragraph}
                showSpeaker={showSpeaker}
                searchQuery={searchQuery}
              />
            </div>
          )
        })}
      </div>
    </div>
  )
}

/**
 * Scroll to a specific paragraph by index
 */
export function useScrollToIndex(
  virtualizerRef: React.RefObject<ReturnType<typeof useVirtualizer> | null>
) {
  return (index: number) => {
    virtualizerRef.current?.scrollToIndex(index, {
      align: 'start',
      behavior: 'auto', // Instant scroll (smooth not supported with dynamic heights)
    })
  }
}
```
  </action>
  <verify>
- File uses 'use client' directive
- useVirtualizer configured with correct options
- measureElement provided for dynamic heights
- useFlushSync set to false for React 19
- Parent container has fixed height and overflow-auto
  </verify>
  <done>VirtualizedReader component renders only visible paragraphs</done>
</task>

<task type="auto">
  <name>Task 3: Update TranscriptReader to use virtualization</name>
  <files>src/components/transcripts/TranscriptReader.tsx</files>
  <action>
Update the TranscriptReader to use VirtualizedReader for paragraph rendering.

Keep the non-virtualized version available for reference but use virtualized by default.

```typescript
'use client'

import { useMemo, useState, useCallback } from 'react'
import Link from 'next/link'
import type { TranscriptWithParagraphs } from '@/lib/types/transcript'
import { TranscriptHeader } from './TranscriptHeader'
import { VirtualizedReader } from './VirtualizedReader'

interface TranscriptReaderProps {
  transcript: TranscriptWithParagraphs
}

export function TranscriptReader({ transcript }: TranscriptReaderProps) {
  const [firstVisibleIndex, setFirstVisibleIndex] = useState(0)

  const paragraphs = useMemo(() => {
    // Sort by position to ensure correct order
    return [...transcript.transcript_paragraphs].sort((a, b) => a.position - b.position)
  }, [transcript.transcript_paragraphs])

  const handleVisibleRangeChange = useCallback((startIndex: number, _endIndex: number) => {
    setFirstVisibleIndex(startIndex)
  }, [])

  const handleScrollToTop = useCallback(() => {
    // For virtualized content, we need to scroll the container
    const container = document.querySelector('[data-virtualized-container]')
    container?.scrollTo({ top: 0, behavior: 'smooth' })
  }, [])

  return (
    <div className="min-h-screen bg-white">
      <div className="mx-auto max-w-3xl px-4 py-12">
        <TranscriptHeader transcript={transcript} />

        {/* Reading progress indicator (optional) */}
        {paragraphs.length > 0 && (
          <div className="mb-4 text-xs text-gray-400">
            {firstVisibleIndex + 1} / {paragraphs.length} paragraphs
          </div>
        )}

        <article className="pb-8" data-virtualized-container>
          <VirtualizedReader
            paragraphs={paragraphs}
            onVisibleRangeChange={handleVisibleRangeChange}
          />
        </article>

        {/* Footer with navigation */}
        <footer className="border-t border-gray-100 pt-8 mt-8">
          <div className="flex justify-between items-center">
            <Link href="/transcripts" className="text-sm text-gray-500 hover:text-gray-700">
              &larr; Back to transcripts
            </Link>
            <button
              onClick={handleScrollToTop}
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              Back to top &uarr;
            </button>
          </div>
        </footer>
      </div>
    </div>
  )
}
```

Also update VirtualizedReader to add the data attribute for scroll-to-top targeting.

In VirtualizedReader.tsx, update the parent div:
```tsx
<div
  ref={parentRef}
  data-virtualized-container
  className="h-[calc(100vh-200px)] overflow-auto"
  // ... rest unchanged
>
```
  </action>
  <verify>
- TranscriptReader imports and uses VirtualizedReader
- Paragraph count indicator shows current position
- Scroll to top button works with virtualized content
- Footer navigation preserved
  </verify>
  <done>TranscriptReader uses virtualization for paragraph rendering</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Virtualized paragraph rendering for large transcripts with 30+ fps scrolling</what-built>
  <how-to-verify>
**Performance testing is CRITICAL for this plan.**

1. Start dev server: `npm run dev`
2. Find the longest transcript in the database:
   ```sql
   SELECT id, title, word_count
   FROM transcripts
   ORDER BY word_count DESC
   LIMIT 5;
   ```
3. Open the longest transcript (should be ~87K words)
4. Open browser DevTools > Performance tab
5. Click "Record" and scroll rapidly through the transcript
6. Stop recording and check:
   - Frame rate should be mostly 30+ fps
   - No major frame drops (red bars)
   - Look for "Layout Shift" warnings
7. Check DOM elements:
   - Open Elements tab
   - While scrolling, only ~15-20 paragraph divs should be in DOM
   - (overscan: 5 + viewport items)
8. Check memory:
   - Open Memory tab
   - Take heap snapshot
   - Scroll through entire transcript
   - Take another snapshot
   - Memory should not grow significantly
9. Verify reading experience:
   - Timestamps still appear in gutter
   - Speaker labels still show on change
   - Text is readable
   - Paragraph indicator updates as you scroll

**If performance is poor (< 30 fps):**
- Check console for React warnings
- Check for layout thrashing in Performance tab
- Try increasing overscan value

Report performance metrics with approval.
  </how-to-verify>
  <resume-signal>Type "approved" with performance metrics (fps, DOM nodes, memory), or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. Open longest transcript (87K words)
2. Scroll rapidly - should be smooth (30+ fps)
3. Check DevTools Performance panel for frame rate
4. Verify only ~15-20 DOM nodes for paragraphs at any time
5. Memory usage stable during scrolling
6. All paragraph content still readable
</verification>

<success_criteria>
- [ ] @tanstack/react-virtual in package.json dependencies
- [ ] Longest transcript (87K words) scrolls at 30+ fps
- [ ] Only visible paragraphs rendered in DOM (check Elements panel)
- [ ] No React 19 flushSync warnings in console
- [ ] Timestamps and speaker labels still display correctly
- [ ] Paragraph position indicator shows current location
- [ ] Memory usage stable during long scrolling sessions
- [ ] npm run build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-reading-interface/03-03-SUMMARY.md`

Include performance metrics in summary:
- Transcript tested (id, word count)
- Average FPS during scrolling
- DOM node count (paragraphs)
- Memory usage before/after scrolling
</output>
