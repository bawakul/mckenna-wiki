---
phase: 03-reading-interface
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - package.json
  - src/components/transcripts/TranscriptSearch.tsx
  - src/components/transcripts/SearchSidebar.tsx
  - src/components/transcripts/VirtualizedReader.tsx
  - src/components/transcripts/TranscriptReader.tsx
  - src/components/transcripts/ParagraphView.tsx
  - src/hooks/useReadingPosition.ts
  - src/components/transcripts/ResumePrompt.tsx
autonomous: false

must_haves:
  truths:
    - "User can search within current transcript to find specific text"
    - "Search results appear in sidebar panel AND as highlights in text"
    - "Clicking search result jumps to that paragraph"
    - "User is prompted to resume reading when returning to transcript"
    - "Reading position is saved to localStorage"
  artifacts:
    - path: "src/components/transcripts/TranscriptSearch.tsx"
      provides: "Search input and logic for in-transcript search"
      min_lines: 40
    - path: "src/components/transcripts/SearchSidebar.tsx"
      provides: "Sidebar showing search results with snippets"
      min_lines: 60
    - path: "src/hooks/useReadingPosition.ts"
      provides: "Hook for saving/restoring reading position"
      min_lines: 40
    - path: "package.json"
      provides: "Updated with react-highlight-words dependency"
      contains: "react-highlight-words"
  key_links:
    - from: "src/components/transcripts/ParagraphView.tsx"
      to: "react-highlight-words"
      via: "search highlighting"
      pattern: "Highlighter"
    - from: "src/components/transcripts/TranscriptReader.tsx"
      to: "src/hooks/useReadingPosition.ts"
      via: "position memory"
      pattern: "useReadingPosition"
---

<objective>
Add in-transcript search with sidebar results and text highlighting, plus reading position memory with resume prompt.

Purpose: Enable finding specific text in transcripts (READ-04) and remembering reading position
Output: Search functionality with sidebar + highlights, and "Continue where you left off?" prompt
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reading-interface/03-CONTEXT.md
@.planning/phases/03-reading-interface/03-RESEARCH.md
@.planning/phases/03-reading-interface/03-01-SUMMARY.md
@.planning/phases/03-reading-interface/03-02-SUMMARY.md
@.planning/phases/03-reading-interface/03-03-SUMMARY.md

# Existing components
@src/components/transcripts/TranscriptReader.tsx
@src/components/transcripts/VirtualizedReader.tsx
@src/components/transcripts/ParagraphView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-highlight-words</name>
  <files>package.json</files>
  <action>
Install react-highlight-words for search highlighting and its types.

```bash
npm install react-highlight-words
npm install -D @types/react-highlight-words
```

Expected additions to package.json:
```json
{
  "dependencies": {
    "react-highlight-words": "^0.20.x"
  },
  "devDependencies": {
    "@types/react-highlight-words": "^0.20.x"
  }
}
```
  </action>
  <verify>
- react-highlight-words in dependencies
- @types/react-highlight-words in devDependencies
- Can import: `import Highlighter from 'react-highlight-words'`
  </verify>
  <done>react-highlight-words and @types/react-highlight-words in package.json, import verification succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Integrate react-highlight-words Highlighter into ParagraphView</name>
  <files>src/components/transcripts/ParagraphView.tsx</files>
  <action>
Update ParagraphView to integrate the react-highlight-words Highlighter component for search match highlighting. Import Highlighter from 'react-highlight-words' and use it to wrap paragraph text when a search query is active.

Design decisions (from 03-CONTEXT.md):
- Search type: plain text only (no regex)
- Results display: highlights in text

```typescript
import Highlighter from 'react-highlight-words'
import type { TranscriptParagraph } from '@/lib/types/transcript'

interface ParagraphViewProps {
  paragraph: TranscriptParagraph
  showSpeaker: boolean
  searchQuery?: string
  isCurrentMatch?: boolean // Highlight the current search result
}

/**
 * Format timestamp for display
 */
function formatTimestamp(timestamp: string | null): string | null {
  if (!timestamp) return null
  return timestamp
}

export function ParagraphView({
  paragraph,
  showSpeaker,
  searchQuery,
  isCurrentMatch = false,
}: ParagraphViewProps) {
  const formattedTimestamp = formatTimestamp(paragraph.timestamp)

  return (
    <div
      className={`
        relative py-2 pl-20 transition-colors duration-200
        ${isCurrentMatch ? 'bg-yellow-50' : ''}
      `}
      data-paragraph-id={paragraph.id}
      data-paragraph-position={paragraph.position}
    >
      {/* Timestamp in left gutter */}
      {formattedTimestamp && (
        <span className="absolute left-0 top-2 w-16 text-right text-xs text-gray-400 font-mono select-none">
          {formattedTimestamp}
        </span>
      )}

      {/* Speaker label (conditional) */}
      {showSpeaker && paragraph.speaker && (
        <div className="mb-1 text-sm font-semibold text-gray-700">
          {paragraph.speaker}
        </div>
      )}

      {/* Paragraph text with optional highlighting */}
      <p className="text-base leading-relaxed text-gray-900">
        {searchQuery ? (
          <Highlighter
            searchWords={[searchQuery]}
            autoEscape={true}
            textToHighlight={paragraph.text}
            highlightClassName="bg-yellow-200 rounded px-0.5"
            caseSensitive={false}
          />
        ) : (
          paragraph.text
        )}
      </p>
    </div>
  )
}

/**
 * Determine if speaker label should be shown for this paragraph
 */
export function shouldShowSpeaker(
  current: TranscriptParagraph,
  previous?: TranscriptParagraph
): boolean {
  if (!current.speaker) return false
  if (!previous) return true // First paragraph
  return current.speaker !== previous.speaker
}

/**
 * Check if paragraph contains search query
 */
export function paragraphMatchesSearch(
  paragraph: TranscriptParagraph,
  query: string
): boolean {
  if (!query || query.length < 2) return false
  return paragraph.text.toLowerCase().includes(query.toLowerCase())
}
```
  </action>
  <verify>
- Highlighter component imported from react-highlight-words
- Search query highlights matches with yellow background
- Current match has additional background highlight
- Case-insensitive matching enabled
  </verify>
  <done>ParagraphView highlights search matches in yellow</done>
</task>

<task type="auto">
  <name>Task 3: Create search sidebar and input components</name>
  <files>src/components/transcripts/TranscriptSearch.tsx, src/components/transcripts/SearchSidebar.tsx</files>
  <action>
Create the search input and sidebar components.

Design decisions (from 03-CONTEXT.md):
- UI: sidebar panel that can stay open
- Results display: sidebar list with context snippets
- Navigation: click items in sidebar to jump
- Search type: plain text only

**src/components/transcripts/TranscriptSearch.tsx:**
```typescript
'use client'

import { useState, useMemo, useCallback } from 'react'
import type { TranscriptParagraph } from '@/lib/types/transcript'

export interface SearchResult {
  paragraphIndex: number
  paragraph: TranscriptParagraph
  snippet: string
  matchCount: number
}

interface UseTranscriptSearchReturn {
  query: string
  setQuery: (query: string) => void
  results: SearchResult[]
  isSearching: boolean
  clearSearch: () => void
}

/**
 * Extract a snippet around the first match
 */
function extractSnippet(text: string, query: string, contextLength: number = 50): string {
  const lowerText = text.toLowerCase()
  const lowerQuery = query.toLowerCase()
  const matchIndex = lowerText.indexOf(lowerQuery)

  if (matchIndex === -1) return text.slice(0, contextLength * 2)

  const start = Math.max(0, matchIndex - contextLength)
  const end = Math.min(text.length, matchIndex + query.length + contextLength)

  let snippet = text.slice(start, end)
  if (start > 0) snippet = '...' + snippet
  if (end < text.length) snippet = snippet + '...'

  return snippet
}

/**
 * Count occurrences of query in text (case-insensitive)
 */
function countMatches(text: string, query: string): number {
  const lowerText = text.toLowerCase()
  const lowerQuery = query.toLowerCase()
  let count = 0
  let pos = 0

  while ((pos = lowerText.indexOf(lowerQuery, pos)) !== -1) {
    count++
    pos += lowerQuery.length
  }

  return count
}

export function useTranscriptSearch(paragraphs: TranscriptParagraph[]): UseTranscriptSearchReturn {
  const [query, setQuery] = useState('')

  const results = useMemo(() => {
    if (!query || query.length < 2) return []

    const searchResults: SearchResult[] = []
    const lowerQuery = query.toLowerCase()

    paragraphs.forEach((paragraph, index) => {
      if (paragraph.text.toLowerCase().includes(lowerQuery)) {
        searchResults.push({
          paragraphIndex: index,
          paragraph,
          snippet: extractSnippet(paragraph.text, query),
          matchCount: countMatches(paragraph.text, query),
        })
      }
    })

    return searchResults
  }, [paragraphs, query])

  const clearSearch = useCallback(() => {
    setQuery('')
  }, [])

  return {
    query,
    setQuery,
    results,
    isSearching: query.length >= 2,
    clearSearch,
  }
}
```

**src/components/transcripts/SearchSidebar.tsx:**
```typescript
'use client'

import { useRef, useEffect } from 'react'
import type { SearchResult } from './TranscriptSearch'
import Highlighter from 'react-highlight-words'

interface SearchSidebarProps {
  query: string
  onQueryChange: (query: string) => void
  results: SearchResult[]
  isOpen: boolean
  onClose: () => void
  onResultClick: (paragraphIndex: number) => void
  currentResultIndex?: number
}

export function SearchSidebar({
  query,
  onQueryChange,
  results,
  isOpen,
  onClose,
  onResultClick,
  currentResultIndex,
}: SearchSidebarProps) {
  const inputRef = useRef<HTMLInputElement>(null)

  // Focus input when sidebar opens
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isOpen])

  if (!isOpen) return null

  const totalMatches = results.reduce((sum, r) => sum + r.matchCount, 0)

  return (
    <div className="fixed right-0 top-0 h-full w-80 bg-white border-l border-gray-200 shadow-lg z-50 flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-gray-100">
        <div className="flex items-center justify-between mb-2">
          <h3 className="font-medium text-gray-900">Search in transcript</h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 p-1"
            aria-label="Close search"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        <input
          ref={inputRef}
          type="text"
          value={query}
          onChange={(e) => onQueryChange(e.target.value)}
          placeholder="Search text..."
          className="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-200"
        />

        {query.length >= 2 && (
          <p className="mt-2 text-xs text-gray-500">
            {results.length === 0
              ? 'No matches found'
              : `${totalMatches} match${totalMatches === 1 ? '' : 'es'} in ${results.length} paragraph${results.length === 1 ? '' : 's'}`
            }
          </p>
        )}
      </div>

      {/* Results list */}
      <div className="flex-1 overflow-auto">
        {results.map((result, index) => (
          <button
            key={result.paragraph.id}
            onClick={() => onResultClick(result.paragraphIndex)}
            className={`
              w-full text-left p-4 border-b border-gray-50 hover:bg-gray-50 transition-colors
              ${currentResultIndex === index ? 'bg-yellow-50' : ''}
            `}
          >
            <div className="text-xs text-gray-400 mb-1">
              Paragraph {result.paragraph.position + 1}
              {result.matchCount > 1 && ` (${result.matchCount} matches)`}
            </div>
            <p className="text-sm text-gray-700 line-clamp-3">
              <Highlighter
                searchWords={[query]}
                autoEscape={true}
                textToHighlight={result.snippet}
                highlightClassName="bg-yellow-200 rounded"
                caseSensitive={false}
              />
            </p>
          </button>
        ))}
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- useTranscriptSearch hook manages search state
- SearchSidebar shows results with highlighted snippets
- Results are clickable
- Match count displayed
  </verify>
  <done>Search sidebar shows results with context snippets and highlighting</done>
</task>

<task type="auto">
  <name>Task 4: Create reading position hook and resume prompt</name>
  <files>src/hooks/useReadingPosition.ts, src/components/transcripts/ResumePrompt.tsx</files>
  <action>
Create the reading position persistence hook and resume prompt component.

Design decisions (from 03-CONTEXT.md):
- Position memory: offer to resume ("Continue where you left off?" prompt)

Implementation notes (from 03-RESEARCH.md):
- Use paragraph index for resilience to content changes
- Debounce position saves
- 7-day expiration for saved positions

**src/hooks/useReadingPosition.ts:**
```typescript
'use client'

import { useState, useEffect, useCallback, useMemo, useRef } from 'react'

interface ReadingPosition {
  transcriptId: string
  paragraphIndex: number
  timestamp: number // When position was saved
}

interface UseReadingPositionOptions {
  transcriptId: string
  expirationDays?: number
}

interface UseReadingPositionReturn {
  savedPosition: ReadingPosition | null
  showResumePrompt: boolean
  dismissResumePrompt: () => void
  savePosition: (paragraphIndex: number) => void
  resumePosition: () => number | null
}

const POSITION_KEY_PREFIX = 'reading-position-'

/**
 * Debounce function for position saving
 */
function debounce<T extends (...args: unknown[]) => void>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout>
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => fn(...args), delay)
  }
}

export function useReadingPosition({
  transcriptId,
  expirationDays = 7,
}: UseReadingPositionOptions): UseReadingPositionReturn {
  const [savedPosition, setSavedPosition] = useState<ReadingPosition | null>(null)
  const [showResumePrompt, setShowResumePrompt] = useState(false)
  const positionSavedRef = useRef(false)

  // Load saved position on mount
  useEffect(() => {
    if (typeof window === 'undefined') return

    try {
      const key = `${POSITION_KEY_PREFIX}${transcriptId}`
      const saved = localStorage.getItem(key)

      if (!saved) return

      const position: ReadingPosition = JSON.parse(saved)
      const daysSinceSaved = (Date.now() - position.timestamp) / (1000 * 60 * 60 * 24)

      // Check if position is within expiration period
      if (daysSinceSaved < expirationDays && position.paragraphIndex > 0) {
        setSavedPosition(position)
        setShowResumePrompt(true)
      } else {
        // Clean up expired position
        localStorage.removeItem(key)
      }
    } catch {
      // Ignore localStorage errors (private browsing, etc.)
    }
  }, [transcriptId, expirationDays])

  // Debounced position save
  const debouncedSave = useMemo(
    () =>
      debounce((paragraphIndex: number) => {
        if (typeof window === 'undefined') return

        try {
          const position: ReadingPosition = {
            transcriptId,
            paragraphIndex,
            timestamp: Date.now(),
          }
          const key = `${POSITION_KEY_PREFIX}${transcriptId}`
          localStorage.setItem(key, JSON.stringify(position))
          positionSavedRef.current = true
        } catch {
          // Ignore localStorage errors
        }
      }, 1000),
    [transcriptId]
  )

  const savePosition = useCallback(
    (paragraphIndex: number) => {
      debouncedSave(paragraphIndex)
    },
    [debouncedSave]
  )

  const dismissResumePrompt = useCallback(() => {
    setShowResumePrompt(false)
  }, [])

  const resumePosition = useCallback(() => {
    if (savedPosition) {
      setShowResumePrompt(false)
      return savedPosition.paragraphIndex
    }
    return null
  }, [savedPosition])

  return {
    savedPosition,
    showResumePrompt,
    dismissResumePrompt,
    savePosition,
    resumePosition,
  }
}
```

**src/components/transcripts/ResumePrompt.tsx:**
```typescript
'use client'

interface ResumePromptProps {
  paragraphIndex: number
  totalParagraphs: number
  onResume: () => void
  onDismiss: () => void
}

export function ResumePrompt({
  paragraphIndex,
  totalParagraphs,
  onResume,
  onDismiss,
}: ResumePromptProps) {
  const progress = Math.round((paragraphIndex / totalParagraphs) * 100)

  return (
    <div className="fixed bottom-4 right-4 bg-white rounded-lg shadow-lg border border-gray-200 p-4 max-w-sm z-40">
      <p className="text-sm text-gray-700 mb-3">
        Continue where you left off?
        <span className="block text-xs text-gray-500 mt-1">
          You were {progress}% through this transcript
        </span>
      </p>
      <div className="flex gap-2">
        <button
          onClick={onResume}
          className="flex-1 rounded-lg bg-gray-900 px-3 py-2 text-sm font-medium text-white hover:bg-gray-800"
        >
          Continue
        </button>
        <button
          onClick={onDismiss}
          className="rounded-lg border border-gray-200 px-3 py-2 text-sm text-gray-600 hover:bg-gray-50"
        >
          Start over
        </button>
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- useReadingPosition persists position to localStorage
- Position saved with debounce (1s delay)
- Expired positions cleaned up (7-day default)
- ResumePrompt shows progress percentage
  </verify>
  <done>Reading position hook and resume prompt component created</done>
</task>

<task type="auto">
  <name>Task 5: Integrate search and position memory into TranscriptReader</name>
  <files>src/components/transcripts/TranscriptReader.tsx, src/components/transcripts/VirtualizedReader.tsx</files>
  <action>
Integrate search functionality and position memory into the main reading interface.

**Updated src/components/transcripts/TranscriptReader.tsx:**
```typescript
'use client'

import { useMemo, useState, useCallback, useRef, useEffect } from 'react'
import Link from 'next/link'
import type { TranscriptWithParagraphs } from '@/lib/types/transcript'
import { TranscriptHeader } from './TranscriptHeader'
import { VirtualizedReader } from './VirtualizedReader'
import { SearchSidebar } from './SearchSidebar'
import { ResumePrompt } from './ResumePrompt'
import { useTranscriptSearch } from './TranscriptSearch'
import { useReadingPosition } from '@/hooks/useReadingPosition'

interface TranscriptReaderProps {
  transcript: TranscriptWithParagraphs
}

export function TranscriptReader({ transcript }: TranscriptReaderProps) {
  const [searchOpen, setSearchOpen] = useState(false)
  const [currentSearchResult, setCurrentSearchResult] = useState<number | undefined>()
  const scrollToIndexRef = useRef<((index: number) => void) | null>(null)

  const paragraphs = useMemo(() => {
    return [...transcript.transcript_paragraphs].sort((a, b) => a.position - b.position)
  }, [transcript.transcript_paragraphs])

  // Search hook
  const { query, setQuery, results, clearSearch } = useTranscriptSearch(paragraphs)

  // Position memory hook
  const {
    savedPosition,
    showResumePrompt,
    dismissResumePrompt,
    savePosition,
    resumePosition,
  } = useReadingPosition({ transcriptId: transcript.id })

  // Handle visible range changes for position memory
  const handleVisibleRangeChange = useCallback(
    (startIndex: number, _endIndex: number) => {
      savePosition(startIndex)
    },
    [savePosition]
  )

  // Handle scroll to index (passed to VirtualizedReader)
  const handleScrollToIndex = useCallback((fn: (index: number) => void) => {
    scrollToIndexRef.current = fn
  }, [])

  // Handle search result click
  const handleSearchResultClick = useCallback((paragraphIndex: number) => {
    setCurrentSearchResult(
      results.findIndex((r) => r.paragraphIndex === paragraphIndex)
    )
    scrollToIndexRef.current?.(paragraphIndex)
  }, [results])

  // Handle resume reading
  const handleResume = useCallback(() => {
    const index = resumePosition()
    if (index !== null) {
      scrollToIndexRef.current?.(index)
    }
  }, [resumePosition])

  // Close search sidebar
  const handleCloseSearch = useCallback(() => {
    setSearchOpen(false)
    clearSearch()
    setCurrentSearchResult(undefined)
  }, [clearSearch])

  // Keyboard shortcut for search (Cmd/Ctrl + F)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        e.preventDefault()
        setSearchOpen(true)
      }
      if (e.key === 'Escape' && searchOpen) {
        handleCloseSearch()
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [searchOpen, handleCloseSearch])

  return (
    <div className="min-h-screen bg-white">
      <div className={`mx-auto max-w-3xl px-4 py-12 ${searchOpen ? 'mr-80' : ''}`}>
        <TranscriptHeader transcript={transcript} />

        {/* Search toggle button */}
        <div className="mb-4 flex items-center justify-between">
          <div className="text-xs text-gray-400">
            {paragraphs.length} paragraphs
          </div>
          <button
            onClick={() => setSearchOpen(true)}
            className="flex items-center gap-2 text-sm text-gray-500 hover:text-gray-700"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <span>Search</span>
            <kbd className="hidden sm:inline-block rounded bg-gray-100 px-1.5 py-0.5 text-xs text-gray-500">
              {typeof window !== 'undefined' && navigator.platform.includes('Mac') ? 'âŒ˜' : 'Ctrl'}+F
            </kbd>
          </button>
        </div>

        <article className="pb-8">
          <VirtualizedReader
            paragraphs={paragraphs}
            searchQuery={query}
            currentSearchParagraphIndex={
              currentSearchResult !== undefined
                ? results[currentSearchResult]?.paragraphIndex
                : undefined
            }
            onVisibleRangeChange={handleVisibleRangeChange}
            onScrollToIndexReady={handleScrollToIndex}
          />
        </article>

        {/* Footer */}
        <footer className="border-t border-gray-100 pt-8 mt-8">
          <div className="flex justify-between items-center">
            <Link href="/transcripts" className="text-sm text-gray-500 hover:text-gray-700">
              &larr; Back to transcripts
            </Link>
          </div>
        </footer>
      </div>

      {/* Search sidebar */}
      <SearchSidebar
        query={query}
        onQueryChange={setQuery}
        results={results}
        isOpen={searchOpen}
        onClose={handleCloseSearch}
        onResultClick={handleSearchResultClick}
        currentResultIndex={currentSearchResult}
      />

      {/* Resume prompt */}
      {showResumePrompt && savedPosition && (
        <ResumePrompt
          paragraphIndex={savedPosition.paragraphIndex}
          totalParagraphs={paragraphs.length}
          onResume={handleResume}
          onDismiss={dismissResumePrompt}
        />
      )}
    </div>
  )
}
```

**Update src/components/transcripts/VirtualizedReader.tsx** to support scroll-to-index callback:
```typescript
'use client'

import { useRef, useMemo, useEffect } from 'react'
import { useVirtualizer } from '@tanstack/react-virtual'
import type { TranscriptParagraph } from '@/lib/types/transcript'
import { ParagraphView, shouldShowSpeaker } from './ParagraphView'

interface VirtualizedReaderProps {
  paragraphs: TranscriptParagraph[]
  searchQuery?: string
  currentSearchParagraphIndex?: number
  onVisibleRangeChange?: (startIndex: number, endIndex: number) => void
  onScrollToIndexReady?: (fn: (index: number) => void) => void
}

export function VirtualizedReader({
  paragraphs,
  searchQuery,
  currentSearchParagraphIndex,
  onVisibleRangeChange,
  onScrollToIndexReady,
}: VirtualizedReaderProps) {
  const parentRef = useRef<HTMLDivElement>(null)

  const speakerVisibility = useMemo(() => {
    return paragraphs.map((para, index) =>
      shouldShowSpeaker(para, paragraphs[index - 1])
    )
  }, [paragraphs])

  const virtualizer = useVirtualizer({
    count: paragraphs.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 80,
    overscan: 5,
    measureElement: (element) => element.getBoundingClientRect().height,
    useFlushSync: false,
  })

  const virtualItems = virtualizer.getVirtualItems()

  // Provide scroll function to parent
  useEffect(() => {
    onScrollToIndexReady?.((index: number) => {
      virtualizer.scrollToIndex(index, {
        align: 'start',
        behavior: 'auto',
      })
    })
  }, [virtualizer, onScrollToIndexReady])

  // Notify parent of visible range changes
  useEffect(() => {
    if (onVisibleRangeChange && virtualItems.length > 0) {
      const startIndex = virtualItems[0]?.index ?? 0
      const endIndex = virtualItems[virtualItems.length - 1]?.index ?? 0
      onVisibleRangeChange(startIndex, endIndex)
    }
  }, [virtualItems, onVisibleRangeChange])

  return (
    <div
      ref={parentRef}
      data-virtualized-container
      className="h-[calc(100vh-200px)] overflow-auto"
      style={{ contain: 'strict' }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualItems.map((virtualItem) => {
          const paragraph = paragraphs[virtualItem.index]
          const showSpeaker = speakerVisibility[virtualItem.index]
          const isCurrentMatch = currentSearchParagraphIndex === virtualItem.index

          return (
            <div
              key={virtualItem.key}
              data-index={virtualItem.index}
              ref={virtualizer.measureElement}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                transform: `translateY(${virtualItem.start}px)`,
              }}
            >
              <ParagraphView
                paragraph={paragraph}
                showSpeaker={showSpeaker}
                searchQuery={searchQuery}
                isCurrentMatch={isCurrentMatch}
              />
            </div>
          )
        })}
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- Search opens with Cmd/Ctrl+F
- Search sidebar displays results
- Clicking result scrolls to paragraph
- Resume prompt appears when returning to transcript
- Position is saved as user scrolls
  </verify>
  <done>Search and position memory fully integrated into reading interface</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete reading interface with search and position memory</what-built>
  <how-to-verify>
**Search testing:**
1. Start dev server: `npm run dev`
2. Open any transcript
3. Press Cmd+F (Mac) or Ctrl+F (Windows)
4. Search sidebar should open on right side
5. Type a search term (e.g., "psychedelic")
6. Verify:
   - Results appear in sidebar with snippets
   - Match count is shown
   - Matches are highlighted in text
   - Click result jumps to paragraph
   - Current result paragraph has yellow background
7. Press Escape to close search

**Position memory testing:**
1. Open a long transcript
2. Scroll down ~50% through transcript
3. Wait 2 seconds (for debounced save)
4. Navigate back to transcript list
5. Re-open the same transcript
6. Verify "Continue where you left off?" prompt appears
7. Click "Continue" - should jump to saved position
8. Test "Start over" - should dismiss prompt and start at top

**Edge cases:**
- Search with no results shows "No matches found"
- Empty search (< 2 chars) shows no results
- Position memory expires after 7 days (can test by manipulating localStorage)

Report any issues found.
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Search with Cmd/Ctrl+F opens sidebar
2. Search results show with highlighted snippets
3. Clicking result jumps to paragraph
4. In-text highlighting matches search query
5. Position is saved to localStorage
6. Resume prompt appears when returning
7. Continue/dismiss buttons work correctly
</verification>

<success_criteria>
- [ ] react-highlight-words in package.json
- [ ] Cmd/Ctrl+F opens search sidebar
- [ ] Search results show in sidebar with context snippets
- [ ] Search matches highlighted in transcript text
- [ ] Clicking search result scrolls to paragraph
- [ ] Reading position saved to localStorage (debounced)
- [ ] Resume prompt shows when returning to transcript
- [ ] "Continue" button jumps to saved position
- [ ] "Start over" button dismisses prompt
- [ ] npm run build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-reading-interface/03-04-SUMMARY.md`
</output>
