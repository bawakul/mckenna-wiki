---
phase: 03-reading-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/transcripts/page.tsx
  - src/app/transcripts/loading.tsx
  - src/components/transcripts/TranscriptListItem.tsx
  - src/components/transcripts/TranscriptFilters.tsx
  - src/components/transcripts/EmptyState.tsx
  - src/lib/types/transcript.ts
autonomous: true

must_haves:
  truths:
    - "User can view all transcripts at /transcripts"
    - "Transcript list is sorted chronologically (oldest first)"
    - "User can filter transcripts by topic tag"
    - "User can search transcripts by title/content from list page"
    - "Each transcript item shows title and date"
  artifacts:
    - path: "src/app/transcripts/page.tsx"
      provides: "Transcript list page (Server Component)"
      min_lines: 50
    - path: "src/components/transcripts/TranscriptListItem.tsx"
      provides: "Single transcript row component"
      min_lines: 20
    - path: "src/lib/types/transcript.ts"
      provides: "TypeScript types for transcripts and paragraphs"
      exports: ["Transcript", "TranscriptParagraph", "TranscriptWithParagraphs"]
  key_links:
    - from: "src/app/transcripts/page.tsx"
      to: "src/lib/supabase/server.ts"
      via: "data fetching"
      pattern: "createClient"
    - from: "src/app/transcripts/page.tsx"
      to: "src/components/transcripts/TranscriptListItem.tsx"
      via: "component composition"
      pattern: "TranscriptListItem"
---

<objective>
Create the transcript list page with chronological sorting, topic tag filtering, and search functionality.

Purpose: Enable users to browse, filter, and find transcripts to read (READ-02)
Output: Transcript list page at /transcripts with filtering and search
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-reading-interface/03-CONTEXT.md
@.planning/phases/03-reading-interface/03-RESEARCH.md

# Existing schema for reference
@supabase/migrations/001_create_corpus_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transcript TypeScript types</name>
  <files>src/lib/types/transcript.ts</files>
  <action>
Create TypeScript types for transcripts and paragraphs that match the database schema.

```typescript
/**
 * Transcript metadata as stored in database
 */
export interface Transcript {
  id: string               // URL slug from organism.earth
  url: string              // Full source URL
  title: string
  date: string | null      // May be year only or full date
  location: string | null
  speakers: string[]       // Array of speaker names
  duration_minutes: number | null
  word_count: number | null
  topic_tags: string[]     // Array of topic/tag strings
  referenced_authors: string[]
  description: string | null
  content_hash: string
  scraped_at: string
  created_at: string
  updated_at: string
}

/**
 * Paragraph within a transcript
 */
export interface TranscriptParagraph {
  id: number
  transcript_id: string
  position: number         // Zero-indexed sequential order
  speaker: string | null   // NULL if not identified
  timestamp: string | null // NULL if not available
  text: string
  content_hash: string     // For stable anchoring
}

/**
 * Transcript with all its paragraphs loaded
 */
export interface TranscriptWithParagraphs extends Transcript {
  transcript_paragraphs: TranscriptParagraph[]
}

/**
 * Minimal transcript data for list display
 */
export interface TranscriptListItem {
  id: string
  title: string
  date: string | null
  word_count: number | null
  topic_tags: string[]
}

/**
 * Format transcript date for display
 * Handles both full dates and year-only formats
 */
export function formatTranscriptDate(date: string | null): string {
  if (!date) return 'Date unknown'

  // Check if it's just a year (4 digits)
  if (/^\d{4}$/.test(date)) {
    return date
  }

  // Try to parse as full date
  try {
    const parsed = new Date(date)
    if (!isNaN(parsed.getTime())) {
      return parsed.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      })
    }
  } catch {
    // Fall through to return raw date
  }

  return date
}

/**
 * Format word count for display
 */
export function formatWordCount(count: number | null): string {
  if (!count) return ''
  if (count >= 1000) {
    return `${(count / 1000).toFixed(1)}k words`
  }
  return `${count} words`
}
```
  </action>
  <verify>
- File exists at src/lib/types/transcript.ts
- TypeScript compiles: `npx tsc --noEmit`
- Types match database schema from 001_create_corpus_tables.sql
  </verify>
  <done>Transcript types defined matching database schema with formatting utilities</done>
</task>

<task type="auto">
  <name>Task 2: Create transcript list item component</name>
  <files>src/components/transcripts/TranscriptListItem.tsx</files>
  <action>
Create a minimal list item component for displaying transcript in the list.

Design decisions (from 03-CONTEXT.md):
- List display: minimal (title + date only)
- Theme: light only (no dark mode)

```typescript
import Link from 'next/link'
import type { TranscriptListItem as TranscriptListItemType } from '@/lib/types/transcript'
import { formatTranscriptDate, formatWordCount } from '@/lib/types/transcript'

interface TranscriptListItemProps {
  transcript: TranscriptListItemType
}

export function TranscriptListItem({ transcript }: TranscriptListItemProps) {
  return (
    <Link
      href={`/transcripts/${transcript.id}`}
      className="block border-b border-gray-100 py-4 hover:bg-gray-50 transition-colors"
    >
      <div className="flex items-baseline justify-between gap-4">
        <h3 className="font-medium text-gray-900 truncate">
          {transcript.title}
        </h3>
        <span className="text-sm text-gray-500 whitespace-nowrap flex-shrink-0">
          {formatTranscriptDate(transcript.date)}
        </span>
      </div>
      {transcript.word_count && (
        <p className="mt-1 text-xs text-gray-400">
          {formatWordCount(transcript.word_count)}
        </p>
      )}
    </Link>
  )
}
```
  </action>
  <verify>
- File exists with proper TypeScript types
- Links to /transcripts/[id] route
- Shows title and formatted date
  </verify>
  <done>TranscriptListItem displays title, date, and links to transcript page</done>
</task>

<task type="auto">
  <name>Task 3: Create filter and search components</name>
  <files>src/components/transcripts/TranscriptFilters.tsx, src/components/transcripts/EmptyState.tsx</files>
  <action>
Create client-side filter and search components for the transcript list.

Design decisions (from 03-CONTEXT.md):
- Filtering: topic tags only
- Search: combined title + full-text corpus search from list page

**src/components/transcripts/TranscriptFilters.tsx:**
```typescript
'use client'

import { useRouter, useSearchParams } from 'next/navigation'
import { useState, useCallback } from 'react'

interface TranscriptFiltersProps {
  availableTags: string[]
  currentTag: string | null
  currentQuery: string | null
}

export function TranscriptFilters({
  availableTags,
  currentTag,
  currentQuery,
}: TranscriptFiltersProps) {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [searchInput, setSearchInput] = useState(currentQuery ?? '')

  const updateParams = useCallback((updates: Record<string, string | null>) => {
    const params = new URLSearchParams(searchParams.toString())

    Object.entries(updates).forEach(([key, value]) => {
      if (value === null || value === '') {
        params.delete(key)
      } else {
        params.set(key, value)
      }
    })

    const queryString = params.toString()
    router.push(`/transcripts${queryString ? `?${queryString}` : ''}`)
  }, [router, searchParams])

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    updateParams({ q: searchInput || null })
  }

  const handleTagClick = (tag: string) => {
    if (currentTag === tag) {
      updateParams({ tag: null })
    } else {
      updateParams({ tag })
    }
  }

  const clearFilters = () => {
    setSearchInput('')
    router.push('/transcripts')
  }

  const hasFilters = currentTag || currentQuery

  return (
    <div className="space-y-4">
      {/* Search input */}
      <form onSubmit={handleSearch} className="flex gap-2">
        <input
          type="text"
          value={searchInput}
          onChange={(e) => setSearchInput(e.target.value)}
          placeholder="Search transcripts..."
          className="flex-1 rounded-lg border border-gray-200 px-4 py-2 text-sm focus:border-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-200"
        />
        <button
          type="submit"
          className="rounded-lg bg-gray-900 px-4 py-2 text-sm font-medium text-white hover:bg-gray-800"
        >
          Search
        </button>
      </form>

      {/* Topic tags */}
      {availableTags.length > 0 && (
        <div className="flex flex-wrap gap-2">
          {availableTags.map((tag) => (
            <button
              key={tag}
              onClick={() => handleTagClick(tag)}
              className={`
                rounded-full px-3 py-1 text-xs font-medium transition-colors
                ${currentTag === tag
                  ? 'bg-gray-900 text-white'
                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                }
              `}
            >
              {tag}
            </button>
          ))}
        </div>
      )}

      {/* Clear filters */}
      {hasFilters && (
        <button
          onClick={clearFilters}
          className="text-sm text-gray-500 underline hover:text-gray-700"
        >
          Clear all filters
        </button>
      )}
    </div>
  )
}
```

**src/components/transcripts/EmptyState.tsx:**
```typescript
interface EmptyStateProps {
  type: 'no-results' | 'no-transcripts'
  query?: string | null
  tag?: string | null
}

export function EmptyState({ type, query, tag }: EmptyStateProps) {
  if (type === 'no-transcripts') {
    return (
      <div className="py-12 text-center">
        <p className="text-gray-600">No transcripts found in the database.</p>
        <p className="mt-2 text-sm text-gray-500">
          Run the seed script to import the corpus.
        </p>
      </div>
    )
  }

  // no-results
  return (
    <div className="py-12 text-center">
      <p className="text-gray-600">
        No transcripts match your {query && tag ? 'search and filter' : query ? 'search' : 'filter'}.
      </p>
      {query && (
        <p className="mt-2 text-sm text-gray-500">
          Try a different search term or clear filters.
        </p>
      )}
    </div>
  )
}
```
  </action>
  <verify>
- TranscriptFilters updates URL params on search/filter
- Tag buttons toggle active state
- EmptyState shows appropriate message for different scenarios
  </verify>
  <done>Filter and empty state components created with URL-based state management</done>
</task>

<task type="auto">
  <name>Task 4: Create transcript list page</name>
  <files>src/app/transcripts/page.tsx, src/app/transcripts/loading.tsx</files>
  <action>
Create the main transcript list page as a Server Component with search and filtering.

Design decisions (from 03-CONTEXT.md):
- Default sort: chronological (oldest first)
- Search: combined title + full-text corpus search

**src/app/transcripts/page.tsx:**
```typescript
import { Suspense } from 'react'
import { createClient } from '@/lib/supabase/server'
import { TranscriptListItem } from '@/components/transcripts/TranscriptListItem'
import { TranscriptFilters } from '@/components/transcripts/TranscriptFilters'
import { EmptyState } from '@/components/transcripts/EmptyState'
import type { TranscriptListItem as TranscriptListItemType } from '@/lib/types/transcript'

interface TranscriptsPageProps {
  searchParams: Promise<{ q?: string; tag?: string }>
}

async function getAvailableTags(supabase: Awaited<ReturnType<typeof createClient>>): Promise<string[]> {
  // Get all unique topic tags across transcripts
  const { data } = await supabase
    .from('transcripts')
    .select('topic_tags')

  if (!data) return []

  const tagSet = new Set<string>()
  data.forEach(t => {
    t.topic_tags?.forEach((tag: string) => tagSet.add(tag))
  })

  return Array.from(tagSet).sort()
}

async function getTranscripts(
  supabase: Awaited<ReturnType<typeof createClient>>,
  query?: string,
  tag?: string
): Promise<TranscriptListItemType[]> {
  // If searching, use full-text search
  if (query && query.trim()) {
    const { data } = await supabase
      .from('transcripts')
      .select('id, title, date, word_count, topic_tags')
      .textSearch('search_vector', query, { type: 'websearch' })
      .order('date', { ascending: true })

    // Apply tag filter post-query if needed
    if (tag && data) {
      return data.filter(t => t.topic_tags?.includes(tag))
    }

    return data ?? []
  }

  // Otherwise, build filter query
  let queryBuilder = supabase
    .from('transcripts')
    .select('id, title, date, word_count, topic_tags')
    .order('date', { ascending: true })

  if (tag) {
    queryBuilder = queryBuilder.contains('topic_tags', [tag])
  }

  const { data } = await queryBuilder
  return data ?? []
}

export default async function TranscriptsPage({ searchParams }: TranscriptsPageProps) {
  const params = await searchParams
  const query = params.q ?? null
  const tag = params.tag ?? null

  const supabase = await createClient()

  const [transcripts, availableTags] = await Promise.all([
    getTranscripts(supabase, query ?? undefined, tag ?? undefined),
    getAvailableTags(supabase),
  ])

  return (
    <div className="min-h-screen bg-white">
      <div className="mx-auto max-w-4xl px-4 py-12">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Transcripts</h1>
          <p className="mt-2 text-gray-600">
            Browse {transcripts.length > 0 ? `${transcripts.length} ` : ''}McKenna lectures chronologically
          </p>
        </div>

        <Suspense fallback={<div className="animate-pulse h-20 bg-gray-100 rounded-lg" />}>
          <TranscriptFilters
            availableTags={availableTags}
            currentTag={tag}
            currentQuery={query}
          />
        </Suspense>

        <div className="mt-8">
          {transcripts.length === 0 ? (
            <EmptyState
              type={!query && !tag ? 'no-transcripts' : 'no-results'}
              query={query}
              tag={tag}
            />
          ) : (
            <div className="divide-y divide-gray-100">
              {transcripts.map((transcript) => (
                <TranscriptListItem key={transcript.id} transcript={transcript} />
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
```

**src/app/transcripts/loading.tsx:**
```typescript
export default function TranscriptsLoading() {
  return (
    <div className="min-h-screen bg-white">
      <div className="mx-auto max-w-4xl px-4 py-12">
        <div className="mb-8">
          <div className="h-9 w-48 bg-gray-200 rounded animate-pulse" />
          <div className="mt-2 h-5 w-64 bg-gray-100 rounded animate-pulse" />
        </div>

        <div className="h-12 bg-gray-100 rounded-lg animate-pulse" />

        <div className="mt-8 space-y-4">
          {[...Array(10)].map((_, i) => (
            <div key={i} className="h-16 bg-gray-50 rounded animate-pulse" />
          ))}
        </div>
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- Visit /transcripts in browser (should show transcript list)
- Search box filters results by title/content
- Topic tag buttons filter by tag
- Empty state displays when no results match
- List is sorted chronologically (oldest first)
  </verify>
  <done>Transcript list page shows all transcripts with search and tag filtering</done>
</task>

</tasks>

<verification>
1. Visit /transcripts - should show all 92 transcripts sorted by date
2. Search for "psychedelic" - should return matching transcripts
3. Click a topic tag - should filter list to that tag
4. Combine search + tag filter - should apply both
5. Clear filters button resets to full list
6. Click transcript item navigates to /transcripts/[id] (404 is expected, page not built yet)
</verification>

<success_criteria>
- [ ] /transcripts shows chronological list of all transcripts (oldest first)
- [ ] Search input performs full-text search across corpus
- [ ] Topic tag buttons filter transcripts by selected tag
- [ ] Empty state shows when no results match filters
- [ ] Loading state displays skeleton while fetching
- [ ] npm run build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-reading-interface/03-01-SUMMARY.md`
</output>
