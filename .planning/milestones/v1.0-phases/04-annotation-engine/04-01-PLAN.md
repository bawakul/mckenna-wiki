---
phase: 04-annotation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/005_create_annotations_table.sql
  - src/lib/types/annotation.ts
  - src/lib/annotations/selectors.ts
autonomous: true

must_haves:
  truths:
    - "Annotations table exists in database with JSONB selector column"
    - "Annotation types are available for import in TypeScript"
    - "W3C selector creation utilities work with DOM Range"
  artifacts:
    - path: "supabase/migrations/005_create_annotations_table.sql"
      provides: "Annotations table with hybrid selector storage"
      contains: "CREATE TABLE annotations"
    - path: "src/lib/types/annotation.ts"
      provides: "TypeScript types for annotations and selectors"
      exports: ["Annotation", "AnnotationSelector", "TextQuoteSelector", "ParagraphAnchor"]
    - path: "src/lib/annotations/selectors.ts"
      provides: "W3C selector creation and word boundary snapping"
      exports: ["createSelectorFromRange", "snapToWordBoundaries"]
  key_links:
    - from: "src/lib/types/annotation.ts"
      to: "supabase annotations table"
      via: "matching column names"
      pattern: "transcript_id.*module_id.*selector"
---

<objective>
Create the database schema and TypeScript foundation for the annotation system.

Purpose: Establish the data model that supports robust text anchoring with W3C-compliant hybrid selectors. This foundation enables highlights to survive transcript text changes.

Output: Database migration, TypeScript types, and selector utilities for creating/parsing W3C annotation selectors.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-annotation-engine/04-CONTEXT.md
@.planning/phases/04-annotation-engine/04-RESEARCH.md
@supabase/migrations/004_create_modules_table.sql
@src/lib/types/transcript.ts
@src/lib/types/module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create annotations database migration</name>
  <files>supabase/migrations/005_create_annotations_table.sql</files>
  <action>
Create the annotations table with:

```sql
CREATE TABLE annotations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  transcript_id TEXT NOT NULL REFERENCES transcripts(id) ON DELETE CASCADE,
  module_id UUID REFERENCES modules(id) ON DELETE SET NULL,  -- Optional, nullable

  -- W3C selector stored as JSONB for flexibility
  selector JSONB NOT NULL,

  -- Denormalized fields for fast queries
  highlighted_text TEXT NOT NULL,
  start_paragraph_id INTEGER REFERENCES transcript_paragraphs(id) ON DELETE CASCADE,
  end_paragraph_id INTEGER REFERENCES transcript_paragraphs(id) ON DELETE CASCADE,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

Add indexes:
- `idx_annotations_transcript` on transcript_id (filter by transcript)
- `idx_annotations_module` on module_id (module trace queries)
- `idx_annotations_paragraphs` on (start_paragraph_id, end_paragraph_id) (viewport queries)
- GIN index on selector JSONB for flexible querying

Add updated_at trigger (reuse existing function from 001).

Add table and column comments explaining:
- module_id is nullable (highlights exist without tags)
- ON DELETE SET NULL keeps highlight if module deleted
- ON DELETE CASCADE removes highlight if paragraph deleted
- selector stores W3C-compliant hybrid selector
  </action>
  <verify>Run `npx supabase db push` or review SQL syntax. Check indexes and foreign key constraints are correct.</verify>
  <done>Migration file exists with annotations table, indexes, and foreign key relationships matching schema from research.</done>
</task>

<task type="auto">
  <name>Task 2: Create annotation TypeScript types</name>
  <files>src/lib/types/annotation.ts</files>
  <action>
Create types matching the database schema and W3C selector model:

```typescript
/**
 * W3C Text Quote Selector
 * Most robust selector - survives minor text edits
 */
export interface TextQuoteSelector {
  type: 'TextQuoteSelector'
  exact: string      // The highlighted text
  prefix: string     // Up to 32 chars before
  suffix: string     // Up to 32 chars after
}

/**
 * W3C Text Position Selector
 * Fast but fragile - breaks if text above changes
 */
export interface TextPositionSelector {
  type: 'TextPositionSelector'
  start: number      // Character offset from document start
  end: number        // Character offset from document end
}

/**
 * Custom paragraph anchor (project-specific)
 * Survives edits in other paragraphs
 */
export interface ParagraphAnchor {
  type: 'ParagraphAnchor'
  paragraphId: number
  startOffset: number  // Offset within paragraph text
  endOffset: number
}

/**
 * Combined selector for robust anchoring
 * Try each in order until one successfully re-anchors
 */
export interface AnnotationSelector {
  type: 'RangeSelector'
  refinedBy: (TextQuoteSelector | TextPositionSelector | ParagraphAnchor)[]
}

/**
 * Annotation as stored in database
 */
export interface Annotation {
  id: string
  transcript_id: string
  module_id: string | null
  selector: AnnotationSelector
  highlighted_text: string
  start_paragraph_id: number
  end_paragraph_id: number
  created_at: string
  updated_at: string
}

/**
 * Annotation with module data joined (for display)
 */
export interface AnnotationWithModule extends Annotation {
  module: {
    id: string
    name: string
    color: string
  } | null
}

/**
 * Input for creating new annotation
 */
export interface CreateAnnotationInput {
  transcript_id: string
  module_id?: string | null
  selector: AnnotationSelector
  highlighted_text: string
  start_paragraph_id: number
  end_paragraph_id: number
}

/**
 * Highlight info for rendering in paragraph
 * Simplified for performance - just what's needed to render
 */
export interface ParagraphHighlight {
  id: string
  startOffset: number
  endOffset: number
  color: string | null  // Module color, null = untagged (gray)
  moduleId: string | null
}

// Context length for TextQuoteSelector prefix/suffix
export const SELECTOR_CONTEXT_LENGTH = 32
```

Export all types and the constant.
  </action>
  <verify>`npm run build` passes with no type errors. Types can be imported from '@/lib/types/annotation'.</verify>
  <done>TypeScript types exist for all annotation-related data structures, matching W3C model and database schema.</done>
</task>

<task type="auto">
  <name>Task 3: Create selector utilities</name>
  <files>src/lib/annotations/selectors.ts</files>
  <action>
Create utility functions for working with DOM selections and W3C selectors:

```typescript
import type {
  AnnotationSelector,
  TextQuoteSelector,
  TextPositionSelector,
  ParagraphAnchor,
  SELECTOR_CONTEXT_LENGTH
} from '@/lib/types/annotation'

/**
 * Snap a Range to word boundaries (no partial words)
 * Expands start backward and end forward to nearest whitespace
 */
export function snapToWordBoundaries(range: Range): Range {
  // Implementation from research Pattern 2
  // Expand startOffset backward until whitespace
  // Expand endOffset forward until whitespace
  // Return new Range with adjusted boundaries
}

/**
 * Get text before a Range for prefix context
 */
export function getTextBefore(range: Range, length: number): string {
  // Walk backward from range start, collecting text
  // Respect node boundaries, concatenate text nodes
  // Return up to `length` characters
}

/**
 * Get text after a Range for suffix context
 */
export function getTextAfter(range: Range, length: number): string {
  // Walk forward from range end, collecting text
  // Return up to `length` characters
}

/**
 * Find paragraph element containing a node
 */
function findParagraphElement(node: Node): Element | null {
  let current: Node | null = node
  while (current) {
    if (current.nodeType === Node.ELEMENT_NODE) {
      const element = current as Element
      if (element.hasAttribute('data-paragraph-id')) {
        return element
      }
    }
    current = current.parentNode
  }
  return null
}

/**
 * Calculate character offset within paragraph text
 */
function getOffsetInParagraph(range: Range, paragraph: Element): { start: number, end: number } {
  // Get paragraph's full text
  // Find where range text appears within it
  // Return start and end offsets
}

/**
 * Create W3C-compliant hybrid selector from DOM Range
 */
export function createSelectorFromRange(
  range: Range,
  transcriptContainer: HTMLElement
): { selector: AnnotationSelector, startParagraphId: number, endParagraphId: number } {
  const exact = range.toString()

  // Create TextQuoteSelector
  const quoteSelector: TextQuoteSelector = {
    type: 'TextQuoteSelector',
    exact,
    prefix: getTextBefore(range, SELECTOR_CONTEXT_LENGTH),
    suffix: getTextAfter(range, SELECTOR_CONTEXT_LENGTH),
  }

  // Create TextPositionSelector (character offset from container start)
  // Note: This is fragile but useful as fast-path
  const positionSelector: TextPositionSelector = {
    type: 'TextPositionSelector',
    start: calculateTextPosition(range.startContainer, range.startOffset, transcriptContainer),
    end: calculateTextPosition(range.endContainer, range.endOffset, transcriptContainer),
  }

  // Create ParagraphAnchor(s)
  const startPara = findParagraphElement(range.startContainer)
  const endPara = findParagraphElement(range.endContainer)

  const paragraphAnchors: ParagraphAnchor[] = []

  if (startPara) {
    const startParagraphId = parseInt(startPara.getAttribute('data-paragraph-id') || '0')
    const offsets = getOffsetInParagraph(range, startPara)
    paragraphAnchors.push({
      type: 'ParagraphAnchor',
      paragraphId: startParagraphId,
      startOffset: offsets.start,
      endOffset: offsets.end,
    })
  }

  // If selection spans multiple paragraphs, add end paragraph anchor too
  if (endPara && endPara !== startPara) {
    const endParagraphId = parseInt(endPara.getAttribute('data-paragraph-id') || '0')
    // For multi-paragraph selections, store start of selection in end paragraph
    paragraphAnchors.push({
      type: 'ParagraphAnchor',
      paragraphId: endParagraphId,
      startOffset: 0,  // Selection continues from start of this paragraph
      endOffset: getOffsetInParagraph(range, endPara).end,
    })
  }

  const selector: AnnotationSelector = {
    type: 'RangeSelector',
    refinedBy: [quoteSelector, positionSelector, ...paragraphAnchors],
  }

  return {
    selector,
    startParagraphId: startPara ? parseInt(startPara.getAttribute('data-paragraph-id') || '0') : 0,
    endParagraphId: endPara ? parseInt(endPara.getAttribute('data-paragraph-id') || '0') : 0,
  }
}

/**
 * Helper: Calculate character position from container start
 */
function calculateTextPosition(node: Node, offset: number, container: Element): number {
  // TreeWalker to count characters before this position
  // Used for TextPositionSelector
}
```

Implementation notes:
- Use data-paragraph-id attribute (already exists on ParagraphView)
- Handle cross-paragraph selections by creating anchors for both start and end paragraphs
- Be defensive about null/missing elements
  </action>
  <verify>`npm run build` passes. Functions can be imported from '@/lib/annotations/selectors'. Test manually with a sample Range if time permits.</verify>
  <done>Selector utilities exist: snapToWordBoundaries, createSelectorFromRange, and helpers for text context extraction.</done>
</task>

</tasks>

<verification>
1. Database migration is valid SQL with correct foreign keys
2. TypeScript types compile without errors
3. Selector utilities are importable and match expected signatures
4. Run `npx supabase db push` to verify schema (local dev)
</verification>

<success_criteria>
- [ ] 005_create_annotations_table.sql exists with table + indexes
- [ ] src/lib/types/annotation.ts exports all annotation types
- [ ] src/lib/annotations/selectors.ts exports selector creation utilities
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-engine/04-01-SUMMARY.md`
</output>
