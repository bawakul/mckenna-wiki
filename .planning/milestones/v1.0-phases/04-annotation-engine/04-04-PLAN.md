---
phase: 04-annotation-engine
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/components/annotations/HighlightRenderer.tsx
  - src/components/transcripts/ParagraphView.tsx
autonomous: true

must_haves:
  truths:
    - "Highlighted text appears with background color in paragraphs"
    - "Untagged highlights show neutral gray background"
    - "Tagged highlights show module color as background"
    - "Highlights are clickable (data-annotation-id attribute present)"
  artifacts:
    - path: "src/components/annotations/HighlightRenderer.tsx"
      provides: "Utility to render text with highlight marks"
      exports: ["renderTextWithHighlights"]
    - path: "src/components/transcripts/ParagraphView.tsx"
      provides: "Updated paragraph view with highlight support"
      contains: "renderTextWithHighlights"
  key_links:
    - from: "ParagraphView.tsx"
      to: "HighlightRenderer.tsx"
      via: "function import"
      pattern: "renderTextWithHighlights"
    - from: "ParagraphView.tsx"
      to: "annotation types"
      via: "ParagraphHighlight prop"
      pattern: "ParagraphHighlight"
---

<objective>
Add highlight rendering to the paragraph view component.

Purpose: Make annotations visible in the transcript text. Each highlighted passage shows a colored background (gray for untagged, module color for tagged).

Output: HighlightRenderer utility and updated ParagraphView that can display highlights.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-annotation-engine/04-CONTEXT.md
@.planning/phases/04-annotation-engine/04-RESEARCH.md
@src/components/transcripts/ParagraphView.tsx
@src/lib/types/annotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HighlightRenderer utility</name>
  <files>src/components/annotations/HighlightRenderer.tsx</files>
  <action>
Create a utility function that renders text with highlight marks:

```typescript
import type { ParagraphHighlight } from '@/lib/types/annotation'

// Default color for untagged highlights (neutral gray)
const UNTAGGED_HIGHLIGHT_COLOR = '#e5e7eb' // Tailwind gray-200

interface TextSegment {
  text: string
  highlight?: ParagraphHighlight
}

/**
 * Split text into segments based on highlights
 * Handles overlapping highlights by using the most recent one
 */
function splitIntoSegments(
  text: string,
  highlights: ParagraphHighlight[]
): TextSegment[] {
  if (highlights.length === 0) {
    return [{ text }]
  }

  // Sort by start offset, then by creation order (later = higher priority)
  // Since we don't have creation order in ParagraphHighlight, use id as proxy
  const sorted = [...highlights].sort((a, b) => {
    if (a.startOffset !== b.startOffset) {
      return a.startOffset - b.startOffset
    }
    // For overlaps starting at same position, later id wins
    return a.id.localeCompare(b.id)
  })

  const segments: TextSegment[] = []
  let currentPos = 0

  // Build non-overlapping segments
  for (const highlight of sorted) {
    // Skip if this highlight starts before current position (overlapped by previous)
    if (highlight.startOffset < currentPos) {
      continue
    }

    // Add unhighlighted text before this highlight
    if (highlight.startOffset > currentPos) {
      segments.push({
        text: text.slice(currentPos, highlight.startOffset),
      })
    }

    // Add highlighted segment
    const endOffset = Math.min(highlight.endOffset, text.length)
    segments.push({
      text: text.slice(highlight.startOffset, endOffset),
      highlight,
    })

    currentPos = endOffset
  }

  // Add remaining unhighlighted text
  if (currentPos < text.length) {
    segments.push({ text: text.slice(currentPos) })
  }

  return segments
}

/**
 * Render text with highlight marks
 * Returns React elements with <mark> tags for highlighted portions
 */
export function renderTextWithHighlights(
  text: string,
  highlights: ParagraphHighlight[]
): React.ReactNode {
  const segments = splitIntoSegments(text, highlights)

  return (
    <>
      {segments.map((segment, index) => {
        if (segment.highlight) {
          const bgColor = segment.highlight.color || UNTAGGED_HIGHLIGHT_COLOR
          return (
            <mark
              key={`${segment.highlight.id}-${index}`}
              data-annotation-id={segment.highlight.id}
              className="cursor-pointer rounded-sm px-0.5 -mx-0.5"
              style={{ backgroundColor: bgColor }}
              role="mark"
              aria-label={
                segment.highlight.moduleId
                  ? 'Highlighted passage (tagged)'
                  : 'Highlighted passage'
              }
            >
              {segment.text}
            </mark>
          )
        }
        return <span key={index}>{segment.text}</span>
      })}
    </>
  )
}

/**
 * Filter highlights to only those within a specific paragraph
 * and adjust offsets to be paragraph-relative
 */
export function getHighlightsForParagraph(
  paragraphId: number,
  paragraphText: string,
  annotations: Array<{
    id: string
    selector: { refinedBy: Array<{ type: string; paragraphId?: number; startOffset?: number; endOffset?: number }> }
    module: { color: string } | null
  }>
): ParagraphHighlight[] {
  const highlights: ParagraphHighlight[] = []

  for (const annotation of annotations) {
    // Find ParagraphAnchor for this paragraph
    const anchor = annotation.selector.refinedBy.find(
      (s) => s.type === 'ParagraphAnchor' && s.paragraphId === paragraphId
    )

    if (anchor && anchor.startOffset !== undefined && anchor.endOffset !== undefined) {
      // Clamp to paragraph text length
      const startOffset = Math.max(0, anchor.startOffset)
      const endOffset = Math.min(paragraphText.length, anchor.endOffset)

      if (startOffset < endOffset) {
        highlights.push({
          id: annotation.id,
          startOffset,
          endOffset,
          color: annotation.module?.color || null,
          moduleId: annotation.module?.id || null,
        })
      }
    }
  }

  return highlights
}
```

Implementation notes:
- Uses ParagraphAnchor from selector to find offsets
- Handles overlapping highlights by taking the first one (sorted by start)
- Uses data-annotation-id for click handling
- Adds aria-label for accessibility
- Negative margin (-mx-0.5) with positive padding (px-0.5) creates slight overlap for visual continuity
  </action>
  <verify>`npm run build` passes. Function correctly splits text into segments.</verify>
  <done>HighlightRenderer creates mark elements with correct colors and data attributes for highlights.</done>
</task>

<task type="auto">
  <name>Task 2: Update ParagraphView to render highlights</name>
  <files>src/components/transcripts/ParagraphView.tsx</files>
  <action>
Update ParagraphView to accept and render highlights.

**IMPORTANT: This integrates with existing search highlighting. The rendering follows a three-way conditional:**
1. If `searchQuery` is active: Use existing Highlighter component (yellow highlight for search matches)
2. Else if `highlights` array has items: Use renderTextWithHighlights (colored annotation highlights)
3. Else: Render plain text

This ensures search and annotations don't conflict - search takes visual priority when active.

1. Add new optional props for highlights:
```typescript
interface ParagraphViewProps {
  paragraph: TranscriptParagraph
  showSpeaker: boolean
  searchQuery?: string
  isCurrentMatch?: boolean
  hasTimestamps?: boolean
  highlights?: ParagraphHighlight[]  // NEW
  onHighlightClick?: (annotationId: string) => void  // NEW
}
```

2. Add imports:
```typescript
import { renderTextWithHighlights } from '@/components/annotations/HighlightRenderer'
import type { ParagraphHighlight } from '@/lib/types/annotation'
```

3. Update the text rendering with complete three-way conditional structure:
```typescript
{/* Paragraph text - three-way conditional for text rendering */}
<p
  className="text-base leading-relaxed text-gray-900"
  onClick={(e) => {
    // Handle highlight clicks (only when not in search mode)
    const target = e.target as HTMLElement
    const annotationId = target.getAttribute('data-annotation-id')
    if (annotationId && onHighlightClick) {
      e.stopPropagation()
      onHighlightClick(annotationId)
    }
  }}
>
  {/* Priority 1: Search highlighting (when user is searching) */}
  {searchQuery ? (
    <Highlighter
      searchWords={[searchQuery]}
      autoEscape={true}
      textToHighlight={paragraph.text}
      highlightClassName="bg-yellow-200 rounded px-0.5"
      caseSensitive={false}
    />
  ) : /* Priority 2: Annotation highlights (when highlights exist) */
  highlights && highlights.length > 0 ? (
    renderTextWithHighlights(paragraph.text, highlights)
  ) : (
    /* Priority 3: Plain text (default) */
    paragraph.text
  )}
</p>
```

**Why this structure:**
- Search highlighting uses the Highlighter component (from react-highlight-words) with yellow bg
- Annotation highlights use renderTextWithHighlights with module colors or gray
- They are mutually exclusive in rendering - search takes priority because:
  - Search is a temporary navigation mode (user wants to find something)
  - Annotations are persistent (always there when not searching)
- The click handler only fires for annotations (data-annotation-id check)

Key changes:
- Add highlights prop (optional, for backward compatibility)
- Add onHighlightClick callback for popover triggering
- Search highlighting takes priority over annotation highlights
- Click handler checks for data-annotation-id and calls callback
  </action>
  <verify>`npm run build` passes. ParagraphView renders correctly in all three modes: search, highlights, plain.</verify>
  <done>ParagraphView displays highlights when provided, handles clicks, and correctly prioritizes search over annotation highlighting.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. ParagraphView still works without highlights (backward compatible)
3. With highlights, text shows colored backgrounds
4. Clicking on highlight triggers onHighlightClick callback
5. When searchQuery is active, search highlighting is shown instead of annotation highlights
</verification>

<success_criteria>
- [ ] HighlightRenderer.tsx exports renderTextWithHighlights
- [ ] ParagraphView accepts highlights prop
- [ ] Highlights render with correct colors
- [ ] Click handling works on highlights
- [ ] Search highlighting takes priority over annotation highlights
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-engine/04-04-SUMMARY.md`
</output>
