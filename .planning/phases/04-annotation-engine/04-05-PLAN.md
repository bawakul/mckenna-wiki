---
phase: 04-annotation-engine
plan: 05
type: execute
wave: 4
depends_on: ["04-02", "04-04"]
files_modified:
  - src/components/annotations/HighlightPopover.tsx
  - src/components/annotations/AnnotationSidebar.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking a highlight shows popover with details"
    - "Popover allows assigning or changing module"
    - "Popover allows deleting the highlight"
    - "Sidebar shows all annotations in current transcript"
    - "Clicking sidebar entry scrolls to highlight"
  artifacts:
    - path: "src/components/annotations/HighlightPopover.tsx"
      provides: "Popover for viewing/editing highlight"
      exports: ["HighlightPopover"]
    - path: "src/components/annotations/AnnotationSidebar.tsx"
      provides: "Sidebar listing all annotations"
      exports: ["AnnotationSidebar"]
  key_links:
    - from: "HighlightPopover.tsx"
      to: "ModuleSelector component"
      via: "component import"
      pattern: "ModuleSelector"
    - from: "AnnotationSidebar.tsx"
      to: "annotation actions"
      via: "server action calls"
      pattern: "updateAnnotationModule|deleteAnnotation"
---

<objective>
Create the popover and sidebar components for interacting with annotations.

Purpose: Enable users to view highlight details, change module tags, delete highlights, and navigate to any highlight in the transcript via the sidebar.

Output: HighlightPopover for editing and AnnotationSidebar for navigation and overview.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-annotation-engine/04-CONTEXT.md
@src/components/modules/ModuleSelector.tsx
@src/app/annotations/actions.ts
@src/lib/types/annotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HighlightPopover component</name>
  <files>src/components/annotations/HighlightPopover.tsx</files>
  <action>
Create the popover that appears when clicking a highlight:

```typescript
'use client'

import { useState } from 'react'
import {
  useFloating,
  useDismiss,
  useInteractions,
  offset,
  flip,
  shift,
  autoUpdate,
} from '@floating-ui/react'
import { ModuleSelector } from '@/components/modules/ModuleSelector'
import { updateAnnotationModule, deleteAnnotation } from '@/app/annotations/actions'
import type { AnnotationWithModule } from '@/lib/types/annotation'

interface HighlightPopoverProps {
  annotation: AnnotationWithModule
  anchorElement: HTMLElement | null
  isOpen: boolean
  onClose: () => void
  onUpdated: () => void  // Callback to refresh annotations after change
}

export function HighlightPopover({
  annotation,
  anchorElement,
  isOpen,
  onClose,
  onUpdated,
}: HighlightPopoverProps) {
  const [isDeleting, setIsDeleting] = useState(false)
  const [isUpdating, setIsUpdating] = useState(false)
  const [showModuleSelector, setShowModuleSelector] = useState(false)

  const { refs, floatingStyles, context } = useFloating({
    open: isOpen,
    onOpenChange: (open) => !open && onClose(),
    placement: 'top',
    middleware: [
      offset(8),
      flip({ fallbackPlacements: ['bottom', 'top-start', 'bottom-start'] }),
      shift({ padding: 8 }),
    ],
    whileElementsMounted: autoUpdate,
  })

  // Set reference to the clicked highlight element
  if (anchorElement && refs.reference.current !== anchorElement) {
    refs.setPositionReference(anchorElement)
  }

  const dismiss = useDismiss(context, { outsidePressEvent: 'mousedown' })
  const { getFloatingProps } = useInteractions([dismiss])

  async function handleModuleSelect(moduleId: string) {
    setIsUpdating(true)
    const result = await updateAnnotationModule(annotation.id, moduleId)
    setIsUpdating(false)
    setShowModuleSelector(false)

    if (result.success) {
      onUpdated()
    }
  }

  async function handleRemoveModule() {
    setIsUpdating(true)
    const result = await updateAnnotationModule(annotation.id, null)
    setIsUpdating(false)

    if (result.success) {
      onUpdated()
    }
  }

  async function handleDelete() {
    if (!confirm('Delete this highlight?')) return

    setIsDeleting(true)
    const result = await deleteAnnotation(annotation.id, annotation.transcript_id)
    setIsDeleting(false)

    if (result.success) {
      onClose()
      onUpdated()
    }
  }

  if (!isOpen) return null

  // Truncate highlighted text for display
  const displayText = annotation.highlighted_text.length > 100
    ? annotation.highlighted_text.slice(0, 100) + '...'
    : annotation.highlighted_text

  return (
    <div
      ref={refs.setFloating}
      style={floatingStyles}
      {...getFloatingProps()}
      className="
        z-50 w-72 bg-white rounded-lg shadow-lg border border-gray-200
        animate-in fade-in-0 zoom-in-95 duration-100
      "
    >
      {/* Header with close button */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-gray-100">
        <span className="text-sm font-medium text-gray-700">
          {annotation.module ? 'Tagged Highlight' : 'Untagged Highlight'}
        </span>
        <button
          type="button"
          onClick={onClose}
          className="text-gray-400 hover:text-gray-600 text-lg leading-none"
        >
          &times;
        </button>
      </div>

      {/* Highlighted text preview */}
      <div className="px-3 py-2 text-sm text-gray-600 bg-gray-50 border-b border-gray-100">
        "{displayText}"
      </div>

      {/* Current module (if tagged) */}
      {annotation.module && (
        <div className="px-3 py-2 flex items-center justify-between border-b border-gray-100">
          <div className="flex items-center gap-2">
            <span
              className="w-3 h-3 rounded-full flex-shrink-0"
              style={{ backgroundColor: annotation.module.color }}
            />
            <span className="text-sm font-medium">{annotation.module.name}</span>
          </div>
          <button
            type="button"
            onClick={handleRemoveModule}
            disabled={isUpdating}
            className="text-xs text-gray-500 hover:text-red-600"
          >
            Remove
          </button>
        </div>
      )}

      {/* Actions */}
      <div className="px-3 py-2 flex items-center gap-2">
        {showModuleSelector ? (
          <div className="flex-1">
            <ModuleSelector
              onSelect={handleModuleSelect}
              onDismiss={() => setShowModuleSelector(false)}
              open={true}
              onOpenChange={(open) => !open && setShowModuleSelector(false)}
              placement="bottom-start"
              trigger={<></>}  // Hidden trigger, we control open state
            />
          </div>
        ) : (
          <>
            <button
              type="button"
              onClick={() => setShowModuleSelector(true)}
              disabled={isUpdating}
              className="
                flex-1 text-sm font-medium text-center
                bg-gray-100 hover:bg-gray-200 text-gray-700
                px-3 py-1.5 rounded-md transition-colors
              "
            >
              {annotation.module ? 'Change Module' : 'Tag with Module'}
            </button>
            <button
              type="button"
              onClick={handleDelete}
              disabled={isDeleting}
              className="
                text-sm text-red-600 hover:text-red-700
                px-3 py-1.5 rounded-md transition-colors
                hover:bg-red-50
              "
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </button>
          </>
        )}
      </div>
    </div>
  )
}
```

Features:
- Shows highlighted text preview (truncated)
- Shows current module if tagged
- "Tag with Module" or "Change Module" button opens ModuleSelector
- "Remove" button clears module (keeps highlight)
- "Delete" button removes entire highlight (with confirmation)
- Uses existing ModuleSelector component from Phase 2
  </action>
  <verify>`npm run build` passes. Component renders with all interactions.</verify>
  <done>HighlightPopover shows annotation details with module tagging and delete capabilities.</done>
</task>

<task type="auto">
  <name>Task 2: Create AnnotationSidebar component</name>
  <files>src/components/annotations/AnnotationSidebar.tsx</files>
  <action>
Create the sidebar that lists all annotations in the transcript:

```typescript
'use client'

import { useState, useCallback } from 'react'
import type { AnnotationWithModule } from '@/lib/types/annotation'

// Default color for untagged highlights
const UNTAGGED_COLOR = '#e5e7eb'

interface AnnotationSidebarProps {
  annotations: AnnotationWithModule[]
  isOpen: boolean
  onToggle: () => void
  onAnnotationClick: (annotationId: string) => void
  /** Currently visible annotation IDs (for highlighting in sidebar) */
  visibleAnnotationIds?: Set<string>
}

export function AnnotationSidebar({
  annotations,
  isOpen,
  onToggle,
  onAnnotationClick,
  visibleAnnotationIds = new Set(),
}: AnnotationSidebarProps) {
  // Sort by document position (start paragraph, then by ID for same paragraph)
  const sortedAnnotations = [...annotations].sort((a, b) => {
    if (a.start_paragraph_id !== b.start_paragraph_id) {
      return a.start_paragraph_id - b.start_paragraph_id
    }
    return a.id.localeCompare(b.id)
  })

  return (
    <>
      {/* Toggle button (always visible) */}
      <button
        type="button"
        onClick={onToggle}
        className="
          fixed right-0 top-1/2 -translate-y-1/2 z-40
          bg-white border border-r-0 border-gray-200
          rounded-l-lg px-1 py-4 shadow-sm
          hover:bg-gray-50 transition-colors
        "
        title={isOpen ? 'Hide annotations' : 'Show annotations'}
      >
        <svg
          className={`w-4 h-4 text-gray-600 transition-transform ${isOpen ? 'rotate-180' : ''}`}
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
        </svg>
      </button>

      {/* Sidebar panel */}
      <aside
        className={`
          fixed right-0 top-0 h-full w-80 z-30
          bg-white border-l border-gray-200 shadow-lg
          transform transition-transform duration-200
          ${isOpen ? 'translate-x-0' : 'translate-x-full'}
          flex flex-col
        `}
      >
        {/* Header */}
        <div className="px-4 py-3 border-b border-gray-100 flex-shrink-0">
          <h2 className="text-sm font-semibold text-gray-800">
            Annotations
            <span className="ml-2 text-gray-500 font-normal">
              ({annotations.length})
            </span>
          </h2>
        </div>

        {/* Annotation list */}
        <div className="flex-1 overflow-y-auto">
          {sortedAnnotations.length === 0 ? (
            <div className="px-4 py-8 text-center text-sm text-gray-500">
              No annotations yet.
              <br />
              <span className="text-gray-400">
                Select text to create highlights.
              </span>
            </div>
          ) : (
            <ul className="divide-y divide-gray-100">
              {sortedAnnotations.map((annotation) => (
                <AnnotationListItem
                  key={annotation.id}
                  annotation={annotation}
                  isVisible={visibleAnnotationIds.has(annotation.id)}
                  onClick={() => onAnnotationClick(annotation.id)}
                />
              ))}
            </ul>
          )}
        </div>
      </aside>
    </>
  )
}

interface AnnotationListItemProps {
  annotation: AnnotationWithModule
  isVisible: boolean
  onClick: () => void
}

function AnnotationListItem({ annotation, isVisible, onClick }: AnnotationListItemProps) {
  // Truncate text for display
  const displayText = annotation.highlighted_text.length > 80
    ? annotation.highlighted_text.slice(0, 80) + '...'
    : annotation.highlighted_text

  const color = annotation.module?.color || UNTAGGED_COLOR

  return (
    <li>
      <button
        type="button"
        onClick={onClick}
        className={`
          w-full text-left px-4 py-3 hover:bg-gray-50 transition-colors
          ${isVisible ? 'bg-amber-50/50' : ''}
        `}
      >
        {/* Color bar + text */}
        <div className="flex gap-3">
          <div
            className="w-1 rounded-full flex-shrink-0"
            style={{ backgroundColor: color }}
          />
          <div className="flex-1 min-w-0">
            <p className="text-sm text-gray-800 line-clamp-2">
              "{displayText}"
            </p>
            {annotation.module && (
              <div className="mt-1 flex items-center gap-1.5">
                <span
                  className="w-2 h-2 rounded-full flex-shrink-0"
                  style={{ backgroundColor: annotation.module.color }}
                />
                <span className="text-xs text-gray-500 truncate">
                  {annotation.module.name}
                </span>
              </div>
            )}
          </div>
        </div>
      </button>
    </li>
  )
}

/**
 * Hook to track which annotations are visible in viewport
 * Uses IntersectionObserver on mark elements
 */
export function useVisibleAnnotations(): {
  visibleIds: Set<string>
  observe: (element: HTMLElement | null) => void
} {
  const [visibleIds, setVisibleIds] = useState<Set<string>>(new Set())

  const observe = useCallback((element: HTMLElement | null) => {
    if (!element) return

    const observer = new IntersectionObserver(
      (entries) => {
        const updates = new Map<string, boolean>()

        entries.forEach((entry) => {
          const id = entry.target.getAttribute('data-annotation-id')
          if (id) {
            updates.set(id, entry.isIntersecting)
          }
        })

        setVisibleIds((prev) => {
          const next = new Set(prev)
          updates.forEach((isVisible, id) => {
            if (isVisible) {
              next.add(id)
            } else {
              next.delete(id)
            }
          })
          return next
        })
      },
      { threshold: 0.5 }
    )

    // Observe all mark elements within the container
    element.querySelectorAll('mark[data-annotation-id]').forEach((mark) => {
      observer.observe(mark)
    })

    return () => observer.disconnect()
  }, [])

  return { visibleIds, observe }
}

/**
 * Scroll to an annotation by ID
 */
export function scrollToAnnotation(annotationId: string): void {
  const mark = document.querySelector(`mark[data-annotation-id="${annotationId}"]`)
  if (mark) {
    mark.scrollIntoView({ behavior: 'smooth', block: 'center' })
  }
}
```

Features:
- Toggle button to show/hide sidebar
- Lists all annotations sorted by document position
- Shows text snippet and module badge if tagged
- Highlights currently visible annotations
- Click to scroll to annotation in document
- Empty state for no annotations
- Exports utility functions for visibility tracking and scrolling
  </action>
  <verify>`npm run build` passes. Sidebar renders with annotation list.</verify>
  <done>AnnotationSidebar lists all highlights with jump-to navigation and visibility tracking.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. HighlightPopover shows and allows module changes
3. AnnotationSidebar lists annotations and scrolls to them
4. Both components integrate with existing ModuleSelector
</verification>

<success_criteria>
- [ ] HighlightPopover.tsx exports the component
- [ ] AnnotationSidebar.tsx exports the component and utilities
- [ ] Module selector integration works
- [ ] Delete and update actions work
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-engine/04-05-SUMMARY.md`
</output>
