---
phase: 04-annotation-engine
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/annotations/actions.ts
  - src/app/modules/actions.ts
autonomous: true

must_haves:
  truths:
    - "Annotations can be created via Server Action"
    - "Annotations can be fetched by transcript ID"
    - "Module can be assigned to or removed from annotation"
    - "Annotations can be deleted"
  artifacts:
    - path: "src/app/annotations/actions.ts"
      provides: "Server Actions for annotation CRUD"
      exports: ["createAnnotation", "getAnnotationsForTranscript", "updateAnnotationModule", "deleteAnnotation"]
  key_links:
    - from: "src/app/annotations/actions.ts"
      to: "supabase annotations table"
      via: "createClient from lib/supabase/server"
      pattern: "supabase\\.from\\('annotations'\\)"
---

<objective>
Create Server Actions for annotation CRUD operations.

Purpose: Provide the data layer for creating, reading, updating, and deleting annotations. These actions are called from client components when user creates highlights or modifies tags.

Output: Server Actions file with functions for all annotation operations.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-annotation-engine/04-01-PLAN.md
@src/app/modules/actions.ts
@src/lib/supabase/server.ts
@src/lib/types/annotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create annotation Server Actions</name>
  <files>src/app/annotations/actions.ts</files>
  <action>
Create Server Actions following the pattern from modules/actions.ts:

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import type {
  Annotation,
  AnnotationWithModule,
  CreateAnnotationInput,
} from '@/lib/types/annotation'

// Reuse ActionResult pattern from modules
type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string }

/**
 * Create a new annotation (highlight)
 */
export async function createAnnotation(
  input: CreateAnnotationInput
): Promise<ActionResult<Annotation>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('annotations')
    .insert({
      transcript_id: input.transcript_id,
      module_id: input.module_id || null,
      selector: input.selector,
      highlighted_text: input.highlighted_text,
      start_paragraph_id: input.start_paragraph_id,
      end_paragraph_id: input.end_paragraph_id,
    })
    .select()
    .single()

  if (error) {
    console.error('Failed to create annotation:', error)
    return { success: false, error: error.message }
  }

  revalidatePath(`/transcripts/${input.transcript_id}`)
  return { success: true, data }
}

/**
 * Get all annotations for a transcript (with module data joined)
 */
export async function getAnnotationsForTranscript(
  transcriptId: string
): Promise<ActionResult<AnnotationWithModule[]>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('annotations')
    .select(`
      *,
      module:modules(id, name, color)
    `)
    .eq('transcript_id', transcriptId)
    .order('start_paragraph_id', { ascending: true })

  if (error) {
    console.error('Failed to fetch annotations:', error)
    return { success: false, error: error.message }
  }

  return { success: true, data: data as AnnotationWithModule[] }
}

/**
 * Get annotations for specific paragraphs (for viewport queries)
 * Used to fetch only annotations visible in current scroll position
 */
export async function getAnnotationsForParagraphs(
  transcriptId: string,
  paragraphIds: number[]
): Promise<ActionResult<AnnotationWithModule[]>> {
  if (paragraphIds.length === 0) {
    return { success: true, data: [] }
  }

  const supabase = await createClient()

  // Annotations where start OR end paragraph is in the list
  const { data, error } = await supabase
    .from('annotations')
    .select(`
      *,
      module:modules(id, name, color)
    `)
    .eq('transcript_id', transcriptId)
    .or(`start_paragraph_id.in.(${paragraphIds.join(',')}),end_paragraph_id.in.(${paragraphIds.join(',')})`)

  if (error) {
    console.error('Failed to fetch paragraph annotations:', error)
    return { success: false, error: error.message }
  }

  return { success: true, data: data as AnnotationWithModule[] }
}

/**
 * Update the module assigned to an annotation
 * Pass null to remove module (keep as untagged highlight)
 */
export async function updateAnnotationModule(
  annotationId: string,
  moduleId: string | null
): Promise<ActionResult<Annotation>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('annotations')
    .update({ module_id: moduleId })
    .eq('id', annotationId)
    .select()
    .single()

  if (error) {
    console.error('Failed to update annotation module:', error)
    return { success: false, error: error.message }
  }

  // Revalidate the transcript page
  revalidatePath(`/transcripts/${data.transcript_id}`)
  return { success: true, data }
}

/**
 * Delete an annotation
 */
export async function deleteAnnotation(
  annotationId: string,
  transcriptId: string
): Promise<ActionResult<null>> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('annotations')
    .delete()
    .eq('id', annotationId)

  if (error) {
    console.error('Failed to delete annotation:', error)
    return { success: false, error: error.message }
  }

  revalidatePath(`/transcripts/${transcriptId}`)
  return { success: true, data: null }
}
```

Key implementation notes:
- Follow ActionResult<T> pattern from modules/actions.ts
- Join with modules table when fetching (for color display)
- revalidatePath after mutations
- getAnnotationsForParagraphs enables viewport-based fetching (performance optimization)
- Note: getAnnotationCountForModule is NOT needed here; the count query is inlined in modules/actions.ts to avoid circular imports
  </action>
  <verify>`npm run build` passes. Server Actions can be called from client components.</verify>
  <done>All CRUD operations for annotations work: create, read by transcript, update module, delete.</done>
</task>

<task type="auto">
  <name>Task 2: Update modules actions to use real annotation count</name>
  <files>src/app/modules/actions.ts</files>
  <action>
Update getModuleWithUsageCount to use real annotation count.

**IMPORTANT: Inline the count query directly in modules/actions.ts.** Do NOT import from annotations/actions.ts as this would create circular imports (annotations imports module types, modules would import annotation actions).

Find the existing function that returns highlight_count: 0 (placeholder from Phase 2).

Update it to query the annotations table directly:

```typescript
export async function getModuleWithUsageCount(
  moduleId: string
): Promise<ActionResult<ModuleWithUsageCount>> {
  const supabase = await createClient()

  // Get module
  const { data: module, error: moduleError } = await supabase
    .from('modules')
    .select('*')
    .eq('id', moduleId)
    .single()

  if (moduleError) {
    return { success: false, error: moduleError.message }
  }

  // Get annotation count - INLINE query, not imported
  // (Importing from annotations/actions.ts would create circular imports)
  const { count, error: countError } = await supabase
    .from('annotations')
    .select('*', { count: 'exact', head: true })
    .eq('module_id', moduleId)

  if (countError) {
    console.error('Failed to count annotations:', countError)
    // Non-fatal: return 0 on error
  }

  return {
    success: true,
    data: {
      ...module,
      highlight_count: count || 0,
    },
  }
}
```

This makes the delete confirmation dialog show accurate usage count.
  </action>
  <verify>Run module delete flow - count should show real annotation count (0 initially, but will show real numbers once annotations exist).</verify>
  <done>Delete module dialog shows real annotation count from database instead of placeholder 0.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Server Actions are callable (test in React component)
3. Database queries are correct (check Supabase dashboard)
4. Module delete dialog shows real count (will be 0 until annotations created)
5. No circular import errors at build time
</verification>

<success_criteria>
- [ ] src/app/annotations/actions.ts exports all CRUD functions
- [ ] Functions use proper error handling with ActionResult
- [ ] Module usage count is now real (not placeholder)
- [ ] No circular imports between modules and annotations actions
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-engine/04-02-SUMMARY.md`
</output>
