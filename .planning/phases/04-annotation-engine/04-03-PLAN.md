---
phase: 04-annotation-engine
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/annotations/useTextSelection.ts
  - src/components/annotations/SelectionToolbar.tsx
autonomous: true

must_haves:
  truths:
    - "Text selection is detected when user finishes selecting"
    - "Floating Highlight button appears near selection"
    - "Selection snaps to word boundaries"
    - "Clicking Highlight button creates annotation"
  artifacts:
    - path: "src/components/annotations/useTextSelection.ts"
      provides: "Hook for detecting text selection"
      exports: ["useTextSelection"]
    - path: "src/components/annotations/SelectionToolbar.tsx"
      provides: "Floating toolbar with Highlight button"
      exports: ["SelectionToolbar"]
  key_links:
    - from: "SelectionToolbar.tsx"
      to: "useTextSelection.ts"
      via: "hook usage"
      pattern: "useTextSelection\\(\\)"
    - from: "SelectionToolbar.tsx"
      to: "@floating-ui/react"
      via: "positioning"
      pattern: "useFloating"
---

<objective>
Create the text selection detection and floating toolbar components.

Purpose: Enable users to select text in transcripts and see a floating "Highlight" button. This is the entry point for creating annotations.

Output: useTextSelection hook and SelectionToolbar component ready for integration.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-annotation-engine/04-CONTEXT.md
@.planning/phases/04-annotation-engine/04-RESEARCH.md
@.planning/phases/04-annotation-engine/04-01-PLAN.md
@src/components/modules/ModuleSelector.tsx
@src/lib/annotations/selectors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTextSelection hook</name>
  <files>src/components/annotations/useTextSelection.ts</files>
  <action>
Create a hook that detects text selection and provides selection data:

```typescript
'use client'

import { useEffect, useState, useCallback, useRef } from 'react'
import { snapToWordBoundaries } from '@/lib/annotations/selectors'

interface SelectionState {
  range: Range | null
  text: string
  rect: DOMRect | null
}

interface UseTextSelectionOptions {
  /** Container element to listen for selections in */
  containerRef: React.RefObject<HTMLElement>
  /** Called when selection is cleared (user clicks elsewhere) */
  onSelectionClear?: () => void
}

export function useTextSelection({ containerRef, onSelectionClear }: UseTextSelectionOptions) {
  const [selection, setSelection] = useState<SelectionState>({
    range: null,
    text: '',
    rect: null,
  })

  // Store selection in ref to avoid stale closure issues
  const selectionRef = useRef<SelectionState>(selection)
  selectionRef.current = selection

  const clearSelection = useCallback(() => {
    setSelection({ range: null, text: '', rect: null })
    onSelectionClear?.()
  }, [onSelectionClear])

  useEffect(() => {
    const container = containerRef.current
    if (!container) return

    function handleMouseUp(event: MouseEvent) {
      // Small delay to let browser finalize selection
      requestAnimationFrame(() => {
        const sel = window.getSelection()

        // No selection or collapsed (just a click)
        if (!sel || sel.isCollapsed) {
          // Only clear if we had a selection before
          if (selectionRef.current.range) {
            clearSelection()
          }
          return
        }

        // Check if selection is within our container
        const range = sel.getRangeAt(0)
        if (!container.contains(range.commonAncestorContainer)) {
          return
        }

        const text = range.toString().trim()
        if (text.length === 0) {
          clearSelection()
          return
        }

        // Snap to word boundaries
        const snappedRange = snapToWordBoundaries(range)
        const snappedText = snappedRange.toString()

        // Get bounding rect for positioning toolbar
        const rect = snappedRange.getBoundingClientRect()

        setSelection({
          range: snappedRange,
          text: snappedText,
          rect,
        })
      })
    }

    // Listen for selections ending
    document.addEventListener('mouseup', handleMouseUp)

    // Clear selection when clicking outside
    function handleClickOutside(event: MouseEvent) {
      const target = event.target as Node
      // If clicking outside container and we have a selection, clear it
      if (!container.contains(target) && selectionRef.current.range) {
        clearSelection()
        window.getSelection()?.removeAllRanges()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)

    return () => {
      document.removeEventListener('mouseup', handleMouseUp)
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [containerRef, clearSelection])

  return {
    selection,
    clearSelection,
    hasSelection: selection.range !== null,
  }
}
```

Key behaviors:
- Only detects selections within the specified container
- Automatically snaps to word boundaries
- Provides bounding rect for toolbar positioning
- Clears selection when clicking outside
- Uses requestAnimationFrame to let browser finalize selection
  </action>
  <verify>`npm run build` passes. Hook can be imported and used in a client component.</verify>
  <done>useTextSelection hook detects text selection, snaps to word boundaries, and provides rect for toolbar positioning.</done>
</task>

<task type="auto">
  <name>Task 2: Create SelectionToolbar component</name>
  <files>src/components/annotations/SelectionToolbar.tsx</files>
  <action>
Create the floating toolbar that appears when text is selected:

```typescript
'use client'

import { useEffect, useMemo } from 'react'
import {
  useFloating,
  offset,
  flip,
  shift,
  autoUpdate,
} from '@floating-ui/react'

interface SelectionToolbarProps {
  /** Bounding rect of the selection */
  selectionRect: DOMRect | null
  /** Called when user clicks Highlight button */
  onHighlight: () => void
  /** Whether to show the toolbar */
  isVisible: boolean
}

export function SelectionToolbar({
  selectionRect,
  onHighlight,
  isVisible,
}: SelectionToolbarProps) {
  // Create virtual element from selection rect
  const virtualElement = useMemo(() => ({
    getBoundingClientRect: () => selectionRect || new DOMRect(),
  }), [selectionRect])

  const { refs, floatingStyles } = useFloating({
    open: isVisible,
    placement: 'top',
    middleware: [
      offset(8),
      flip({ fallbackPlacements: ['bottom', 'top-start', 'bottom-start'] }),
      shift({ padding: 8 }),
    ],
    whileElementsMounted: autoUpdate,
  })

  // Update reference when selection changes
  useEffect(() => {
    if (isVisible && selectionRect) {
      refs.setPositionReference(virtualElement)
    }
  }, [isVisible, selectionRect, virtualElement, refs])

  if (!isVisible || !selectionRect) {
    return null
  }

  return (
    <div
      ref={refs.setFloating}
      style={floatingStyles}
      className="
        z-50 bg-white rounded-lg shadow-lg border border-gray-200
        px-2 py-1.5 flex items-center gap-2
        animate-in fade-in-0 zoom-in-95 duration-100
      "
    >
      <button
        type="button"
        onClick={(e) => {
          e.preventDefault()
          e.stopPropagation()
          onHighlight()
        }}
        className="
          text-sm font-medium text-amber-700 hover:text-amber-800
          bg-amber-50 hover:bg-amber-100
          px-3 py-1 rounded-md
          transition-colors
        "
      >
        Highlight
      </button>
    </div>
  )
}
```

Design notes:
- Uses Floating UI (already in project from Phase 2)
- Positions above selection by default, flips to bottom if needed
- Amber/yellow theme to match highlighting concept
- Simple single button for now (module selector comes via popover after creation)
- Prevents event bubbling to avoid unintended selection clearing
  </action>
  <verify>`npm run build` passes. Component renders floating button when given a selection rect.</verify>
  <done>SelectionToolbar component appears near text selection with Highlight button.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Components can be imported from '@/components/annotations/*'
3. useTextSelection detects selection and provides rect
4. SelectionToolbar positions correctly near selection
</verification>

<success_criteria>
- [ ] useTextSelection.ts exports the hook
- [ ] SelectionToolbar.tsx exports the component
- [ ] Word boundary snapping is working
- [ ] `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-annotation-engine/04-03-SUMMARY.md`
</output>
