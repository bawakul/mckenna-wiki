---
phase: 02-module-system
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/modules/actions.ts
autonomous: true

must_haves:
  truths:
    - "User can create a new module via Server Action"
    - "User can update an existing module via Server Action"
    - "User can delete a module via Server Action"
    - "Deleting a module warns with affected highlight count"
  artifacts:
    - path: "src/app/modules/actions.ts"
      provides: "Server Actions for module CRUD"
      exports: ["createModule", "updateModule", "deleteModule", "getModuleWithUsageCount"]
  key_links:
    - from: "src/app/modules/actions.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
    - from: "src/app/modules/actions.ts"
      to: "src/lib/types/module.ts"
      via: "type imports"
      pattern: "import.*ModuleInputSchema.*from.*types/module"
---

<objective>
Implement Server Actions for module CRUD operations with validation and cache revalidation.

Purpose: Provide the data mutation layer for all module management operations
Output: Server Actions file with create, read, update, delete functions
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-module-system/02-CONTEXT.md
@.planning/phases/02-module-system/02-RESEARCH.md
@.planning/phases/02-module-system/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement module CRUD Server Actions</name>
  <files>src/app/modules/actions.ts</files>
  <action>
Create Server Actions for all module operations following Next.js 16 patterns.

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { ModuleInputSchema, PRESET_COLORS, type Module, type ModuleWithUsageCount } from '@/lib/types/module'

type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: string; fieldErrors?: Record<string, string[]> }

/**
 * Create a new module
 */
export async function createModule(formData: FormData): Promise<ActionResult<Module>> {
  // Parse and validate input
  const rawInput = {
    name: formData.get('name'),
    notes: formData.get('notes') || '',
    color: formData.get('color') || PRESET_COLORS[0].value,
  }

  const parsed = ModuleInputSchema.safeParse(rawInput)
  if (!parsed.success) {
    return {
      success: false,
      error: 'Validation failed',
      fieldErrors: parsed.error.flatten().fieldErrors,
    }
  }

  const supabase = await createClient()
  const { data, error } = await supabase
    .from('modules')
    .insert({
      name: parsed.data.name,
      notes: parsed.data.notes || null,
      color: parsed.data.color,
    })
    .select()
    .single()

  if (error) {
    // Handle unique constraint violation (duplicate name)
    if (error.code === '23505') {
      return {
        success: false,
        error: 'A module with this name already exists',
        fieldErrors: { name: ['A module with this name already exists'] },
      }
    }
    return { success: false, error: error.message }
  }

  revalidatePath('/modules')
  return { success: true, data }
}

/**
 * Update an existing module
 */
export async function updateModule(
  id: string,
  formData: FormData
): Promise<ActionResult<Module>> {
  const rawInput = {
    name: formData.get('name'),
    notes: formData.get('notes') || '',
    color: formData.get('color'),
  }

  const parsed = ModuleInputSchema.safeParse(rawInput)
  if (!parsed.success) {
    return {
      success: false,
      error: 'Validation failed',
      fieldErrors: parsed.error.flatten().fieldErrors,
    }
  }

  const supabase = await createClient()
  const { data, error } = await supabase
    .from('modules')
    .update({
      name: parsed.data.name,
      notes: parsed.data.notes || null,
      color: parsed.data.color,
    })
    .eq('id', id)
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      return {
        success: false,
        error: 'A module with this name already exists',
        fieldErrors: { name: ['A module with this name already exists'] },
      }
    }
    return { success: false, error: error.message }
  }

  revalidatePath('/modules')
  revalidatePath(`/modules/${id}`)
  return { success: true, data }
}

/**
 * Get module with count of highlights that reference it
 * Used before deletion to warn user of affected highlights
 */
export async function getModuleWithUsageCount(
  id: string
): Promise<ActionResult<ModuleWithUsageCount>> {
  const supabase = await createClient()

  // Get module
  const { data: module, error: moduleError } = await supabase
    .from('modules')
    .select('*')
    .eq('id', id)
    .single()

  if (moduleError) {
    return { success: false, error: moduleError.message }
  }

  // Count highlights referencing this module
  // Note: highlights table doesn't exist yet (Phase 4), so return 0 for now
  // When highlights table exists, use:
  // const { count } = await supabase
  //   .from('highlights')
  //   .select('*', { count: 'exact', head: true })
  //   .eq('module_id', id)
  const highlight_count = 0

  return {
    success: true,
    data: { ...module, highlight_count },
  }
}

/**
 * Delete a module
 * Highlights that referenced this module will have their module_id set to NULL
 * (handled by database ON DELETE SET NULL when highlights table exists)
 */
export async function deleteModule(id: string): Promise<ActionResult<null>> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('modules')
    .delete()
    .eq('id', id)

  if (error) {
    return { success: false, error: error.message }
  }

  revalidatePath('/modules')
  return { success: true, data: null }
}

/**
 * Update module's last_used_at timestamp
 * Called when a highlight is tagged with this module
 */
export async function touchModuleLastUsed(id: string): Promise<void> {
  const supabase = await createClient()
  await supabase
    .from('modules')
    .update({ last_used_at: new Date().toISOString() })
    .eq('id', id)

  // Don't revalidate - this is a background operation
}

/**
 * Get all modules sorted by last_used_at (recently used first)
 * Used by the floating selector during reading
 */
export async function getModulesSortedByRecent(): Promise<ActionResult<Module[]>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('modules')
    .select('*')
    .order('last_used_at', { ascending: false, nullsFirst: false })
    .order('created_at', { ascending: false })

  if (error) {
    return { success: false, error: error.message }
  }

  return { success: true, data: data ?? [] }
}
```

Key patterns implemented:
1. Zod validation before database operations
2. Structured ActionResult type for consistent error handling
3. revalidatePath() after mutations for cache invalidation
4. Duplicate name handling via PostgreSQL error code 23505
5. last_used_at tracking for "recently used" sorting
  </action>
  <verify>
- File compiles without TypeScript errors: `npx tsc --noEmit`
- All exports are present: createModule, updateModule, deleteModule, getModuleWithUsageCount, touchModuleLastUsed, getModulesSortedByRecent
  </verify>
  <done>All module CRUD Server Actions implemented with validation and cache revalidation</done>
</task>

<task type="auto">
  <name>Task 2: Add path alias for lib imports</name>
  <files>tsconfig.json</files>
  <action>
Ensure tsconfig.json has path alias for `@/lib/*` imports. Check if it exists; if not, add it.

The paths section should include:
```json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

This allows imports like:
- `import { createClient } from '@/lib/supabase/server'`
- `import { Module } from '@/lib/types/module'`

If already configured (typical in Next.js projects), verify it works by checking that the Server Actions file has no import errors.
  </action>
  <verify>
- tsconfig.json has "@/*" path alias
- Imports in actions.ts resolve correctly
- `npx tsc --noEmit` passes
  </verify>
  <done>Path aliases configured and imports working</done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` succeeds
2. Server Actions can be imported: test in a Server Component
3. Each action returns proper ActionResult type
</verification>

<success_criteria>
- [ ] src/app/modules/actions.ts exists with 'use server' directive
- [ ] createModule validates input and handles duplicate names
- [ ] updateModule validates input and revalidates paths
- [ ] deleteModule removes module (highlights will be handled in Phase 4)
- [ ] getModulesSortedByRecent returns modules ordered by last_used_at
- [ ] All imports resolve correctly (no TypeScript errors)
</success_criteria>

<output>
After completion, create `.planning/phases/02-module-system/02-02-SUMMARY.md`
</output>
