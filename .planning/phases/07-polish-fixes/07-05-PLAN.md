---
phase: 07-polish-fixes
plan: 05
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/annotations/useTextSelection.ts
  - src/lib/annotations/selectors.ts
  - src/components/annotations/HighlightRenderer.tsx
  - src/components/annotations/SelectionToolbar.tsx
  - src/components/transcripts/VirtualizedReader.tsx
autonomous: true
requirements: []

must_haves:
  truths:
    - "User can select text spanning multiple paragraphs and create a single highlight"
    - "Multi-paragraph highlights render as a connected block across all spanned paragraphs"
    - "Middle paragraphs (not start/end) are fully highlighted"
    - "Partial first and last paragraphs preserve exact selection boundaries"
    - "Selections exceeding 15 paragraphs are rejected with a user-visible message"
    - "Popover anchors to the first paragraph's mark element when clicking any part of a multi-paragraph highlight"
  artifacts:
    - path: "src/components/annotations/useTextSelection.ts"
      provides: "Paragraph count validation with MAX_HIGHLIGHT_PARAGRAPHS cap"
      contains: "MAX_HIGHLIGHT_PARAGRAPHS"
    - path: "src/lib/annotations/selectors.ts"
      provides: "createSelectorFromRange with middle paragraph ParagraphAnchors"
      contains: "getAllParagraphsBetween"
    - path: "src/components/annotations/HighlightRenderer.tsx"
      provides: "getHighlightForParagraph with middle paragraph full-span fallback"
      contains: "isMiddle"
  key_links:
    - from: "src/components/annotations/useTextSelection.ts"
      to: "src/components/annotations/SelectionToolbar.tsx"
      via: "Selection validation before toolbar display"
      pattern: "MAX_HIGHLIGHT_PARAGRAPHS"
    - from: "src/lib/annotations/selectors.ts"
      to: "src/components/annotations/HighlightRenderer.tsx"
      via: "ParagraphAnchor data stored by selectors, consumed by renderer"
      pattern: "ParagraphAnchor"
    - from: "src/components/annotations/HighlightRenderer.tsx"
      to: "src/components/transcripts/VirtualizedReader.tsx"
      via: "getHighlightsForParagraph called per rendered paragraph"
      pattern: "getHighlightsForParagraph"
---

<objective>
Enable multi-paragraph highlights: validate paragraph count during selection, store ParagraphAnchors for all paragraphs in the range, and render middle paragraphs with full-span highlighting. The data model already supports multi-paragraph spans (start_paragraph_id != end_paragraph_id) — this plan fills in the selection, storage, and rendering gaps.

Purpose: Allow users to highlight passages that span multiple paragraphs as a single connected annotation
Output: Updated selection validation, selector creation, and highlight rendering
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-fixes/07-RESEARCH.md
@.planning/phases/07-polish-fixes/07-01-SUMMARY.md
@src/components/annotations/useTextSelection.ts
@src/lib/annotations/selectors.ts
@src/components/annotations/HighlightRenderer.tsx
@src/lib/types/annotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add paragraph count validation and multi-paragraph selector creation</name>
  <files>
    src/components/annotations/useTextSelection.ts
    src/lib/annotations/selectors.ts
    src/components/annotations/SelectionToolbar.tsx
  </files>
  <action>
**1. Add paragraph counting and cap to `useTextSelection.ts`:**

Export a constant `MAX_HIGHLIGHT_PARAGRAPHS = 15` at the top of the file.

Add a helper function `countParagraphsInRange(range: Range): number` that:
- Gets the common ancestor container
- Uses a TreeWalker with `NodeFilter.SHOW_ELEMENT` filtering for elements with `data-paragraph-id` attribute
- Counts and returns the number of paragraph elements that intersect the range
- Returns `Math.max(1, count)` (minimum 1)

In the `handleMouseUp` callback, after snapping to word boundaries:
- Call `countParagraphsInRange(snappedRange)`
- If count exceeds `MAX_HIGHLIGHT_PARAGRAPHS`, set a new state field `exceedsLimit: true` and clear the selection range
- Add `exceedsLimit` to the returned state and a `clearExceedsLimit` callback

**2. Update `SelectionToolbar.tsx`:**

Accept `exceedsLimit` prop. When true, show a warning message near the toolbar: "Selection too large (max 15 paragraphs)" in red/amber text. Auto-dismiss after 3 seconds via setTimeout.

**3. Update `createSelectorFromRange` in `selectors.ts`:**

After adding the start paragraph anchor and before the end paragraph check, add middle paragraph anchors.

Add a helper function `getAllParagraphsBetween(startPara: Element, endPara: Element): Element[]`:
- Walk forward from `startPara` through sibling/next elements
- Collect all elements with `data-paragraph-id` attribute that are after `startPara` and before `endPara` (exclusive of both)
- Return the collected elements

In `createSelectorFromRange`, after the start paragraph anchor push:
```typescript
// Add middle paragraph anchors (full-span) for multi-paragraph selections
if (endPara && endPara !== startPara) {
  const middleParagraphs = getAllParagraphsBetween(startPara, endPara);
  for (const middlePara of middleParagraphs) {
    const middleId = parseInt(middlePara.getAttribute('data-paragraph-id') || '0', 10);
    const textElement = middlePara.querySelector('p');
    const textLength = textElement?.textContent?.length ?? middlePara.textContent?.length ?? 0;
    paragraphAnchors.push({
      type: 'ParagraphAnchor',
      paragraphId: middleId,
      startOffset: 0,
      endOffset: textLength,
    });
  }
}
```

The `getAllParagraphsBetween` function must work within the virtualized reader's DOM. Since the overscan is 5, and selections are capped at 15 paragraphs, all relevant paragraph elements should be in the DOM.

**Important:** The offset bug fix from Plan 07-01 must be applied first — `getOffsetInParagraph` now scopes to the `<p>` element, so middle paragraph `endOffset` should also use `querySelector('p')?.textContent?.length` for consistency.
  </action>
  <verify>
    <automated>cd "/Users/bharadwajkulkarni/Documents /Bawa's Lab/mckenna-wiki" && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Select text across 3 paragraphs — toolbar should appear. Select across 20+ paragraphs — warning message should appear instead of toolbar.</manual>
  </verify>
  <done>Selection validates paragraph count (cap at 15), createSelectorFromRange stores ParagraphAnchors for all paragraphs (start, middle, end)</done>
</task>

<task type="auto">
  <name>Task 2: Update highlight rendering for multi-paragraph spans</name>
  <files>
    src/components/annotations/HighlightRenderer.tsx
    src/components/transcripts/VirtualizedReader.tsx
  </files>
  <action>
**1. Update `getHighlightForParagraph` in `HighlightRenderer.tsx`:**

After the range check (`paragraphId < start || > end → null`), before the ParagraphAnchor lookup, add a middle paragraph check:

```typescript
export function getHighlightForParagraph(
  annotation: AnnotationWithModule,
  paragraphId: number
): ParagraphHighlight | null {
  // Check if this paragraph is within the annotation's range
  if (paragraphId < annotation.start_paragraph_id || paragraphId > annotation.end_paragraph_id) {
    return null
  }

  const selector = annotation.selector
  if (!selector || selector.type !== 'RangeSelector' || !selector.refinedBy) {
    return null
  }

  // First try: look for explicit ParagraphAnchor for this paragraph
  for (const refined of selector.refinedBy) {
    if (refined.type === 'ParagraphAnchor' && (refined as ParagraphAnchor).paragraphId === paragraphId) {
      const anchor = refined as ParagraphAnchor
      return {
        id: annotation.id,
        startOffset: anchor.startOffset,
        endOffset: anchor.endOffset,
        color: annotation.module?.color ?? null,
        moduleId: annotation.module_id,
      }
    }
  }

  // Fallback for middle paragraphs without explicit ParagraphAnchor
  // (supports both new annotations with explicit anchors and legacy multi-paragraph annotations)
  const isMiddle = annotation.start_paragraph_id !== annotation.end_paragraph_id &&
                   paragraphId > annotation.start_paragraph_id &&
                   paragraphId < annotation.end_paragraph_id
  if (isMiddle) {
    // Full paragraph highlight — use a large endOffset that will be clamped by splitIntoSegments
    return {
      id: annotation.id,
      startOffset: 0,
      endOffset: 999999, // Will be clamped to text.length by splitIntoSegments
      color: annotation.module?.color ?? null,
      moduleId: annotation.module_id,
    }
  }

  return null
}
```

Note: Using `999999` for endOffset is safe because `splitIntoSegments` already clamps: `const end = Math.max(start, Math.min(highlight.endOffset, text.length))`. This avoids needing to pass `paragraphTextLength` as a parameter.

**2. Update VirtualizedReader.tsx:**

Verify that the component passes annotations to `getHighlightsForParagraph` correctly. The existing implementation should work without changes since `getHighlightsForParagraph` calls `getHighlightForParagraph` for each annotation, and the updated function now handles middle paragraphs.

Check the highlight popover's click handler — when clicking a multi-paragraph highlight, the popover should anchor to the first mark element for that annotation (which is the start paragraph). The existing `document.querySelector(`mark[data-annotation-id="${annotationId}"]`)` pattern naturally returns the first DOM match, which is the start paragraph's mark. Verify this is the current behavior; if the popover uses `refs.setReference` on the clicked mark instead, update it to find the first mark:

```typescript
// In handleHighlightClick:
const firstMark = document.querySelector(`mark[data-annotation-id="${annotationId}"]`) as HTMLElement;
if (firstMark) {
  refs.setReference(firstMark);
}
```

This ensures the popover anchors to the start of the multi-paragraph highlight per user decision.
  </action>
  <verify>
    <automated>cd "/Users/bharadwajkulkarni/Documents /Bawa's Lab/mckenna-wiki" && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Create a highlight spanning 3 paragraphs — verify all 3 paragraphs show highlight color. Click the highlight in the middle paragraph — verify popover anchors to the first paragraph's mark.</manual>
  </verify>
  <done>Middle paragraphs render full-span highlights. Multi-paragraph highlights display as connected blocks. Popover anchors to first paragraph's mark element.</done>
</task>

</tasks>

<verification>
- [ ] `MAX_HIGHLIGHT_PARAGRAPHS = 15` exported from useTextSelection
- [ ] Selections exceeding 15 paragraphs show warning and are rejected
- [ ] `createSelectorFromRange` stores ParagraphAnchors for start, middle, and end paragraphs
- [ ] `getHighlightForParagraph` handles middle paragraphs with full-span highlight
- [ ] Popover anchors to first mark element for multi-paragraph highlights
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
- Multi-paragraph highlights can be created (up to 15 paragraphs)
- All spanned paragraphs render with connected highlight color
- Partial first/last paragraphs preserve exact selection boundaries
- Popover anchors to start paragraph per user decision
- Selection cap prevents accidental huge selections
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-fixes/07-05-SUMMARY.md`
</output>
